{"version":3,"sources":["index.js","globals.js","utils/index.js","utils/createError.js","utils/getParserHelpers.js","utils/getRefreshGlobal.js","utils/getSocketIntegration.js","utils/injectRefreshEntry.js","utils/injectRefreshLoader.js","utils/normalizeOptions.js","options.json","runtime/RefreshRuntimeModule.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ACHA,AFMA;ADIA,ADGA,AGTA,ACHA,AFMA;ADIA,ADGA,AGTA,ACHA,AFMA;ADIA,ADGA,AGTA,ACHA,ACHA,AHSA;ADIA,ADGA,AGTA,ACHA,ACHA,AHSA;AFOA,AGTA,ACHA,ACHA,AHSA;AFOA,AGTA,ACHA,ACHA,ACHA,AJYA;AFOA,AGTA,ACHA,ACHA,ACHA,AJYA;AFOA,AIZA,ACHA,ACHA,AJYA;AFOA,AIZA,ACHA,ACHA,AJYA,AKfA;APsBA,AIZA,ACHA,ACHA,AJYA,AKfA;APsBA,AIZA,ACHA,ACHA,AJYA,AKfA;APsBA,AIZA,ACHA,ACHA,ACHA,ACHA;ARyBA,AIZA,ACHA,ACHA,ACHA,ACHA;ARyBA,AIZA,ACHA,ACHA,ACHA,ACHA;ARyBA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,APqBA,ACHA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,ANkBA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,ANkBA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,ANkBA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,ANkBA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,ANkBA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,ANkBA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,ANkBA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,ANkBA,AENA,ACHA,ACHA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ACHA,ANkBA,AENA,AENA;AT4BA,AU9BA,ALeA,AENA,AENA;AT4BA,AU9BA,ALeA,AENA,AENA;AT4BA,AU9BA,ALeA,AENA,AENA;AT4BA,AU9BA,ALeA,AENA,AENA;AT4BA,AU9BA,ALeA,AENA,AENA;AT4BA,AU9BA,ALeA,AENA,AENA;AT4BA,AU9BA,ALeA,AENA,AENA;AT4BA,AU9BA,ALeA,AENA,AENA;AT4BA,AU9BA,ALeA,AENA,AENA;AT4BA,AU9BA,AHSA,AENA;AT4BA,AU9BA,AHSA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA,AENA;AT4BA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const validateOptions = require('schema-utils');\nconst { DefinePlugin, ModuleFilenameHelpers, ProvidePlugin, Template } = require('webpack');\nconst ConstDependency = require('webpack/lib/dependencies/ConstDependency');\nconst { refreshGlobal, webpackRequire, webpackVersion } = require('./globals');\nconst {\n  createError,\n  getParserHelpers,\n  getRefreshGlobal,\n  getSocketIntegration,\n  injectRefreshEntry,\n  injectRefreshLoader,\n  normalizeOptions,\n} = require('./utils');\nconst schema = require('./options.json');\n\n// Mapping of react-refresh globals to Webpack runtime globals\nconst REPLACEMENTS = {\n  $RefreshRuntime$: {\n    expr: `${refreshGlobal}.runtime`,\n    req: [webpackRequire, `${refreshGlobal}.runtime`],\n    type: 'object',\n  },\n  $RefreshSetup$: {\n    expr: `${refreshGlobal}.setup`,\n    req: [webpackRequire, `${refreshGlobal}.setup`],\n    type: 'function',\n  },\n  $RefreshCleanup$: {\n    expr: `${refreshGlobal}.cleanup`,\n    req: [webpackRequire, `${refreshGlobal}.cleanup`],\n    type: 'function',\n  },\n  $RefreshReg$: {\n    expr: `${refreshGlobal}.register`,\n    req: [webpackRequire, `${refreshGlobal}.register`],\n    type: 'function',\n  },\n  $RefreshSig$: {\n    expr: `${refreshGlobal}.signature`,\n    req: [webpackRequire, `${refreshGlobal}.signature`],\n    type: 'function',\n  },\n};\n\nclass ReactRefreshPlugin {\n  /**\n   * @param {import('./types').ReactRefreshPluginOptions} [options] Options for react-refresh-plugin.\n   */\n  constructor(options = {}) {\n    validateOptions(schema, options, {\n      name: 'React Refresh Plugin',\n      baseDataPath: 'options',\n    });\n\n    /**\n     * @readonly\n     * @type {import('./types').NormalizedPluginOptions}\n     */\n    this.options = normalizeOptions(options);\n  }\n\n  /**\n   * Applies the plugin.\n   * @param {import('webpack').Compiler} compiler A webpack compiler object.\n   * @returns {void}\n   */\n  apply(compiler) {\n    // Throw if we encounter an unsupported Webpack version,\n    // since things will most likely not work.\n    if (webpackVersion !== 4 && webpackVersion !== 5) {\n      throw createError(`Webpack v${webpackVersion} is not supported!`);\n    }\n\n    // Skip processing in non-development mode, but allow manual force-enabling\n    if (\n      // Webpack do not set process.env.NODE_ENV, so we need to check for mode.\n      // Ref: https://github.com/webpack/webpack/issues/7074\n      (compiler.options.mode !== 'development' ||\n        // We also check for production process.env.NODE_ENV,\n        // in case it was set and mode is non-development (e.g. 'none')\n        (process.env.NODE_ENV && process.env.NODE_ENV === 'production')) &&\n      !this.options.forceEnable\n    ) {\n      return;\n    }\n\n    // Inject react-refresh context to all Webpack entry points\n    compiler.options.entry = injectRefreshEntry(compiler.options.entry, this.options);\n\n    // Inject necessary modules to bundle's global scope\n    /** @type {Record<string, string>} */\n    let providedModules = {\n      __react_refresh_utils__: require.resolve('./runtime/RefreshUtils'),\n    };\n\n    if (this.options.overlay === false) {\n      // Stub errorOverlay module so calls to it can be erased\n      const definePlugin = new DefinePlugin({\n        __react_refresh_error_overlay__: false,\n        __react_refresh_init_socket__: false,\n      });\n      definePlugin.apply(compiler);\n    } else {\n      providedModules = {\n        ...providedModules,\n        ...(this.options.overlay.module && {\n          __react_refresh_error_overlay__: require.resolve(this.options.overlay.module),\n        }),\n        ...(this.options.overlay.sockIntegration && {\n          __react_refresh_init_socket__: getSocketIntegration(this.options.overlay.sockIntegration),\n        }),\n      };\n    }\n\n    const providePlugin = new ProvidePlugin(providedModules);\n    providePlugin.apply(compiler);\n\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, this.options);\n    const { evaluateToString, toConstantDependency } = getParserHelpers();\n    compiler.hooks.compilation.tap(\n      this.constructor.name,\n      (compilation, { normalModuleFactory }) => {\n        // Only hook into the current compiler\n        if (compilation.compiler !== compiler) {\n          return;\n        }\n\n        // Set template for ConstDependency which is used by parser hooks\n        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n\n        // Tap into version-specific compilation hooks\n        switch (webpackVersion) {\n          case 4: {\n            const outputOptions = compilation.mainTemplate.outputOptions;\n            compilation.mainTemplate.hooks.require.tap(\n              this.constructor.name,\n              // Constructs the module template for react-refresh\n              (source, chunk, hash) => {\n                // Check for the output filename\n                // This is to ensure we are processing a JS-related chunk\n                let filename = outputOptions.filename;\n                if (typeof filename === 'function') {\n                  // Only usage of the `chunk` property is documented by Webpack.\n                  // However, some internal Webpack plugins uses other properties,\n                  // so we also pass them through to be on the safe side.\n                  filename = filename({\n                    contentHashType: 'javascript',\n                    chunk,\n                    hash,\n                  });\n                }\n\n                // Check whether the current compilation is outputting to JS,\n                // since other plugins can trigger compilations for other file types too.\n                // If we apply the transform to them, their compilation will break fatally.\n                // One prominent example of this is the HTMLWebpackPlugin.\n                // If filename is falsy, something is terribly wrong and there's nothing we can do.\n                if (!filename || !filename.includes('.js')) {\n                  return source;\n                }\n\n                // Split template source code into lines for easier processing\n                const lines = source.split('\\n');\n                // Webpack generates this line when the MainTemplate is called\n                const moduleInitializationLineNumber = lines.findIndex((line) =>\n                  line.includes('modules[moduleId].call(')\n                );\n                // Unable to find call to module execution -\n                // this happens if the current module does not call MainTemplate.\n                // In this case, we will return the original source and won't mess with it.\n                if (moduleInitializationLineNumber === -1) {\n                  return source;\n                }\n\n                const moduleInterceptor = Template.asString([\n                  `${refreshGlobal}.init();`,\n                  'try {',\n                  Template.indent(lines[moduleInitializationLineNumber]),\n                  '} finally {',\n                  Template.indent(`${refreshGlobal}.cleanup(moduleId);`),\n                  '}',\n                ]);\n\n                return Template.asString([\n                  ...lines.slice(0, moduleInitializationLineNumber),\n                  '',\n                  outputOptions.strictModuleExceptionHandling\n                    ? Template.indent(moduleInterceptor)\n                    : moduleInterceptor,\n                  '',\n                  ...lines.slice(moduleInitializationLineNumber + 1, lines.length),\n                ]);\n              }\n            );\n\n            compilation.mainTemplate.hooks.requireExtensions.tap(\n              this.constructor.name,\n              // Setup react-refresh globals as extensions to Webpack's require function\n              (source) => {\n                return Template.asString([source, '', getRefreshGlobal()]);\n              }\n            );\n\n            normalModuleFactory.hooks.afterResolve.tap(\n              this.constructor.name,\n              // Add react-refresh loader to process files that matches specified criteria\n              (data) => {\n                return injectRefreshLoader(data, matchObject);\n              }\n            );\n\n            compilation.hooks.normalModuleLoader.tap(\n              // `Infinity` ensures this check will run only after all other taps\n              { name: this.constructor.name, stage: Infinity },\n              // Check for existence of the HMR runtime -\n              // it is the foundation to this plugin working correctly\n              (context) => {\n                if (!context.hot) {\n                  throw createError(\n                    [\n                      'Hot Module Replacement (HMR) is not enabled!',\n                      'React Refresh requires HMR to function properly.',\n                    ].join(' ')\n                  );\n                }\n              }\n            );\n\n            break;\n          }\n          case 5: {\n            const NormalModule = require('webpack/lib/NormalModule');\n            const RuntimeGlobals = require('webpack/lib/RuntimeGlobals');\n            const ReactRefreshRuntimeModule = require('./runtime/RefreshRuntimeModule');\n\n            compilation.hooks.additionalTreeRuntimeRequirements.tap(\n              this.constructor.name,\n              // Setup react-refresh globals with a Webpack runtime module\n              (chunk, runtimeRequirements) => {\n                runtimeRequirements.add(RuntimeGlobals.interceptModuleExecution);\n                compilation.addRuntimeModule(chunk, new ReactRefreshRuntimeModule());\n              }\n            );\n\n            normalModuleFactory.hooks.afterResolve.tap(\n              this.constructor.name,\n              // Add react-refresh loader to process files that matches specified criteria\n              (resolveData) => {\n                injectRefreshLoader(resolveData.createData, matchObject);\n              }\n            );\n\n            NormalModule.getCompilationHooks(compilation).loader.tap(\n              // `Infinity` ensures this check will run only after all other taps\n              { name: this.constructor.name, stage: Infinity },\n              // Check for existence of the HMR runtime -\n              // it is the foundation to this plugin working correctly\n              (context) => {\n                if (!context.hot) {\n                  throw createError(\n                    [\n                      'Hot Module Replacement (HMR) is not enabled!',\n                      'React Refresh requires HMR to function properly.',\n                    ].join(' ')\n                  );\n                }\n              }\n            );\n\n            break;\n          }\n          default: {\n            throw createError(`Encountered unexpected Webpack version (v${webpackVersion})`);\n          }\n        }\n\n        /**\n         * Transform global calls into Webpack runtime calls.\n         * @param {*} parser\n         * @returns {void}\n         */\n        const parserHandler = (parser) => {\n          Object.entries(REPLACEMENTS).forEach(([key, info]) => {\n            parser.hooks.expression\n              .for(key)\n              .tap(this.constructor.name, toConstantDependency(parser, info.expr, info.req));\n\n            if (info.type) {\n              parser.hooks.evaluateTypeof\n                .for(key)\n                .tap(this.constructor.name, evaluateToString(info.type));\n            }\n          });\n        };\n\n        normalModuleFactory.hooks.parser\n          .for('javascript/auto')\n          .tap(this.constructor.name, parserHandler);\n        normalModuleFactory.hooks.parser\n          .for('javascript/dynamic')\n          .tap(this.constructor.name, parserHandler);\n        normalModuleFactory.hooks.parser\n          .for('javascript/esm')\n          .tap(this.constructor.name, parserHandler);\n      }\n    );\n  }\n}\n\nmodule.exports.ReactRefreshPlugin = ReactRefreshPlugin;\nmodule.exports = ReactRefreshPlugin;\n","const { version } = require('webpack');\n\n// Parse Webpack's major version: x.y.z => x\nconst webpackVersion = parseInt(version || '', 10);\n\nlet webpackGlobals = {};\nif (webpackVersion === 5) {\n  webpackGlobals = require('webpack/lib/RuntimeGlobals');\n}\n\nmodule.exports.webpackVersion = webpackVersion;\nmodule.exports.webpackRequire = webpackGlobals.require || '__webpack_require__';\nmodule.exports.refreshGlobal = `${module.exports.webpackRequire}.$Refresh$`;\n","const createError = require('./createError');\nconst getParserHelpers = require('./getParserHelpers');\nconst getRefreshGlobal = require('./getRefreshGlobal');\nconst getSocketIntegration = require('./getSocketIntegration');\nconst injectRefreshEntry = require('./injectRefreshEntry');\nconst injectRefreshLoader = require('./injectRefreshLoader');\nconst normalizeOptions = require('./normalizeOptions');\n\nmodule.exports = {\n  createError,\n  getParserHelpers,\n  getRefreshGlobal,\n  getSocketIntegration,\n  injectRefreshEntry,\n  injectRefreshLoader,\n  normalizeOptions,\n};\n","/**\n * Creates an error with the plugin's prefix.\n * @param {string} message The error's message.\n * @returns {Error} The created error object.\n */\nfunction createError(message) {\n  return new Error(`[React Refresh] ${message}`);\n}\n\nmodule.exports = createError;\n","const { webpackVersion } = require('../globals');\n\n/**\n * @callback EvaluateToString\n * @param {string} value\n * @returns {function(*): *}\n */\n\n/**\n * @callback ToConstantDependency\n * @param {*} parser\n * @param {string} value\n * @param {string[]} [runtimeRequirements]\n * @returns {function(*): boolean}\n */\n\n/**\n * @typedef {Object} ParserHelpers\n * @property {EvaluateToString} evaluateToString\n * @property {ToConstantDependency} toConstantDependency\n */\n\n/**\n * Gets parser helpers for specific webpack versions.\n * @returns {ParserHelpers} The needed parser helpers.\n */\nfunction getParserHelpers() {\n  if (webpackVersion === 4) {\n    const {\n      evaluateToString,\n      toConstantDependencyWithWebpackRequire,\n    } = require('webpack/lib/ParserHelpers');\n    return {\n      evaluateToString,\n      toConstantDependency: toConstantDependencyWithWebpackRequire,\n    };\n  }\n\n  if (webpackVersion === 5) {\n    return require('webpack/lib/javascript/JavascriptParserHelpers');\n  }\n}\n\nmodule.exports = getParserHelpers;\n","const Template = require('webpack/lib/Template');\nconst { refreshGlobal } = require('../globals');\n\n/**\n * @typedef {Object} RuntimeTemplate\n * @property {function(string, string[]): string} basicFunction\n * @property {function(): boolean} supportsConst\n * @property {function(string, string=): string} returningFunction\n */\n\n/** @type {RuntimeTemplate} */\nconst FALLBACK_RUNTIME_TEMPLATE = {\n  basicFunction(args, body) {\n    return `function(${args}) {\\n${Template.indent(body)}\\n}`;\n  },\n  supportsConst() {\n    return false;\n  },\n  returningFunction(returnValue, args = '') {\n    return `function(${args}) { return ${returnValue}; }`;\n  },\n};\n\n/**\n * Generates the refresh global runtime template.\n * @param {RuntimeTemplate} [runtimeTemplate] The runtime template helpers.\n * @returns {string} The refresh global runtime template.\n */\nfunction getRefreshGlobal(runtimeTemplate = FALLBACK_RUNTIME_TEMPLATE) {\n  const declaration = runtimeTemplate.supportsConst() ? 'const' : 'var';\n  return Template.asString([\n    `${refreshGlobal} = {`,\n    Template.indent([\n      `init: ${runtimeTemplate.basicFunction('', [\n        `${refreshGlobal}.cleanup = ${runtimeTemplate.returningFunction('undefined')};`,\n        `${refreshGlobal}.register = ${runtimeTemplate.returningFunction('undefined')};`,\n        `${refreshGlobal}.runtime = {};`,\n        `${refreshGlobal}.signature = ${runtimeTemplate.returningFunction(\n          runtimeTemplate.returningFunction('type', 'type')\n        )};`,\n      ])},`,\n      `setup: ${runtimeTemplate.basicFunction('currentModuleId', [\n        `${declaration} prevCleanup = ${refreshGlobal}.cleanup;`,\n        `${declaration} prevReg = ${refreshGlobal}.register;`,\n        `${declaration} prevSig = ${refreshGlobal}.signature;`,\n        '',\n        `${refreshGlobal}.register = ${runtimeTemplate.basicFunction('type, id', [\n          `${declaration} typeId = currentModuleId + \" \" + id;`,\n          `${refreshGlobal}.runtime.register(type, typeId);`,\n        ])}`,\n        '',\n        `${refreshGlobal}.signature = ${refreshGlobal}.runtime.createSignatureFunctionForTransform;`,\n        '',\n        `${refreshGlobal}.cleanup = ${runtimeTemplate.basicFunction('cleanupModuleId', [\n          'if (currentModuleId === cleanupModuleId) {',\n          Template.indent([\n            `${refreshGlobal}.register = prevReg;`,\n            `${refreshGlobal}.signature = prevSig;`,\n            `${refreshGlobal}.cleanup = prevCleanup;`,\n          ]),\n          '}',\n        ])}`,\n      ])},`,\n    ]),\n    '};',\n  ]);\n}\n\nmodule.exports = getRefreshGlobal;\n","/**\n * Gets the socket integration to use for Webpack messages.\n * @param {'wds' | 'whm' | 'wps' | string} integrationType A valid socket integration type or a path to a module.\n * @returns {string} Path to the resolved socket integration module.\n */\nfunction getSocketIntegration(integrationType) {\n  let resolvedSocketIntegration;\n  switch (integrationType) {\n    case 'wds': {\n      resolvedSocketIntegration = require.resolve('../../sockets/WDSSocket');\n      break;\n    }\n    case 'whm': {\n      resolvedSocketIntegration = require.resolve('../../sockets/WHMEventSource');\n      break;\n    }\n    case 'wps': {\n      resolvedSocketIntegration = require.resolve('../../sockets/WPSSocket');\n      break;\n    }\n    default: {\n      resolvedSocketIntegration = require.resolve(integrationType);\n      break;\n    }\n  }\n\n  return resolvedSocketIntegration;\n}\n\nmodule.exports = getSocketIntegration;\n","const querystring = require('querystring');\nconst createError = require('./createError');\n\n/** @typedef {string | string[] | import('webpack').Entry} StaticEntry */\n/** @typedef {StaticEntry | import('webpack').EntryFunc} WebpackEntry */\n\n/**\n * Checks if a Webpack entry string is related to socket integrations.\n * @param {string} entry A Webpack entry string.\n * @returns {boolean} Whether the entry is related to socket integrations.\n */\nfunction isSocketEntry(entry) {\n  /**\n   * Webpack entries related to socket integrations.\n   * They have to run before any code that sets up the error overlay.\n   * @type {string[]}\n   */\n  const socketEntries = [\n    'webpack-dev-server/client',\n    'webpack-hot-middleware/client',\n    'webpack-plugin-serve/client',\n    'react-dev-utils/webpackHotDevClient',\n  ];\n\n  return socketEntries.some((socketEntry) => entry.includes(socketEntry));\n}\n\n/**\n * Injects an entry to the bundle for react-refresh.\n * @param {WebpackEntry} [originalEntry] A Webpack entry object.\n * @param {import('../types').NormalizedPluginOptions} options Configuration options for this plugin.\n * @returns {WebpackEntry} An injected entry object.\n */\nfunction injectRefreshEntry(originalEntry, options) {\n  /** @type {Record<string, *>} */\n  let resourceQuery = {};\n  if (options.overlay) {\n    options.overlay.sockHost && (resourceQuery.sockHost = options.overlay.sockHost);\n    options.overlay.sockPath && (resourceQuery.sockPath = options.overlay.sockPath);\n    options.overlay.sockPort && (resourceQuery.sockPort = options.overlay.sockPort);\n  }\n\n  // We don't need to URI encode the resourceQuery as it will be parsed by Webpack\n  const queryString = querystring.stringify(resourceQuery, undefined, undefined, {\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    encodeURIComponent(string) {\n      return string;\n    },\n  });\n\n  const prependEntries = [\n    // React-refresh runtime\n    require.resolve('../../client/ReactRefreshEntry'),\n  ];\n\n  const overlayEntries = [\n    // Legacy WDS SockJS integration\n    options.overlay &&\n      options.overlay.useLegacyWDSSockets &&\n      require.resolve('../../client/LegacyWDSSocketEntry'),\n    // Error overlay runtime\n    options.overlay &&\n      options.overlay.entry &&\n      options.overlay.entry + (queryString && `?${queryString}`),\n  ].filter(Boolean);\n\n  // Single string entry point\n  if (typeof originalEntry === 'string') {\n    if (isSocketEntry(originalEntry)) {\n      return [...prependEntries, originalEntry, ...overlayEntries];\n    }\n\n    return [...prependEntries, ...overlayEntries, originalEntry];\n  }\n  // Single array entry point\n  if (Array.isArray(originalEntry)) {\n    const socketEntryIndex = originalEntry.findIndex(isSocketEntry);\n\n    let socketAndPrecedingEntries = [];\n    if (socketEntryIndex !== -1) {\n      socketAndPrecedingEntries = originalEntry.splice(0, socketEntryIndex + 1);\n    }\n\n    return [...prependEntries, ...socketAndPrecedingEntries, ...overlayEntries, ...originalEntry];\n  }\n  // Multiple entry points\n  if (typeof originalEntry === 'object') {\n    return Object.entries(originalEntry).reduce(\n      (acc, [curKey, curEntry]) => ({\n        ...acc,\n        [curKey]:\n          typeof curEntry === 'object' && curEntry.import\n            ? {\n                ...curEntry,\n                import: injectRefreshEntry(curEntry.import, options),\n              }\n            : injectRefreshEntry(curEntry, options),\n      }),\n      {}\n    );\n  }\n  // Dynamic entry points\n  if (typeof originalEntry === 'function') {\n    return (...args) =>\n      Promise.resolve(originalEntry(...args)).then((resolvedEntry) =>\n        injectRefreshEntry(resolvedEntry, options)\n      );\n  }\n\n  throw createError('Failed to parse the Webpack `entry` object!');\n}\n\nmodule.exports = injectRefreshEntry;\n","const path = require('path');\n\n/**\n * @callback MatchObject\n * @param {string} [str]\n * @returns {boolean}\n */\n\nconst resolvedLoader = require.resolve('../../loader');\n\n/**\n * Injects refresh loader to all JavaScript-like and user-specified files.\n * @param {*} data Module factory creation data.\n * @param {MatchObject} matchObject A function to include/exclude files to be processed.\n * @returns {*} The injected module factory creation data.\n */\nfunction injectRefreshLoader(data, matchObject) {\n  if (\n    // Include and exclude user-specified files\n    matchObject(data.resource) &&\n    // Skip plugin's runtime utils to prevent self-referencing -\n    // this is useful when using the plugin as a direct dependency.\n    !data.resource.includes(path.join(__dirname, '../runtime/RefreshUtils')) &&\n    // Check to prevent double injection\n    !data.loaders.find(({ loader }) => loader === resolvedLoader)\n  ) {\n    // As we inject runtime code for each module,\n    // it is important to run the injected loader after everything.\n    // This way we can ensure that all code-processing have been done,\n    // and we won't risk breaking tools like Flow or ESLint.\n    data.loaders.unshift({\n      loader: resolvedLoader,\n      options: undefined,\n    });\n  }\n\n  return data;\n}\n\nmodule.exports = injectRefreshLoader;\n","/**\n * Sets a constant default value for the property when it is undefined.\n * @template T\n * @template {keyof T} Property\n * @param {T} object An object.\n * @param {Property} property A property of the provided object.\n * @param {T[Property]} defaultValue The default value to set for the property.\n * @returns {T[Property]} The defaulted property value.\n */\nconst d = (object, property, defaultValue) => {\n  if (typeof object[property] === 'undefined' && typeof defaultValue !== 'undefined') {\n    object[property] = defaultValue;\n  }\n  return object[property];\n};\n\n/**\n * Resolves the value for a nested object option.\n * @template T\n * @template {keyof T} Property\n * @template Result\n * @param {T} object An object.\n * @param {Property} property A property of the provided object.\n * @param {function(T | undefined): Result} fn The handler to resolve the property's value.\n * @returns {Result} The resolved option value.\n */\nconst nestedOption = (object, property, fn) => {\n  object[property] = fn(object[property]);\n  return object[property];\n};\n\n/**\n * Normalizes the options for the plugin.\n * @param {import('../types').ReactRefreshPluginOptions} options Non-normalized plugin options.\n * @returns {import('../types').NormalizedPluginOptions} Normalized plugin options.\n */\nconst normalizeOptions = (options) => {\n  // Show deprecation notice for the `disableRefreshCheck` option and remove it\n  if (typeof options.disableRefreshCheck !== 'undefined') {\n    delete options.disableRefreshCheck;\n    console.warn(\n      [\n        'The \"disableRefreshCheck\" option has been deprecated and will not have any effect on how the plugin parses files.',\n        'Please remove it from your configuration.',\n      ].join(' ')\n    );\n  }\n\n  d(options, 'exclude', /node_modules/i);\n  d(options, 'include', /\\.([jt]sx?|flow)$/i);\n  d(options, 'forceEnable');\n\n  nestedOption(options, 'overlay', (overlay) => {\n    /** @type {import('../types').NormalizedErrorOverlayOptions} */\n    const defaults = {\n      entry: require.resolve('../../client/ErrorOverlayEntry'),\n      module: require.resolve('../../overlay'),\n      sockIntegration: 'wds',\n    };\n\n    if (overlay === false) {\n      return false;\n    }\n    if (typeof overlay === 'undefined' || overlay === true) {\n      return defaults;\n    }\n\n    d(overlay, 'entry', defaults.entry);\n    d(overlay, 'module', defaults.module);\n    d(overlay, 'sockIntegration', defaults.sockIntegration);\n    d(overlay, 'sockHost');\n    d(overlay, 'sockPath');\n    d(overlay, 'sockPort');\n    d(options, 'useLegacyWDSSockets');\n\n    return overlay;\n  });\n\n  return options;\n};\n\nmodule.exports = normalizeOptions;\n","module.exports = {\n  \"additionalProperties\": false,\n  \"type\": \"object\",\n  \"definitions\": {\n    \"MatchCondition\": {\n      \"anyOf\": [{ \"instanceof\": \"RegExp\" }, { \"$ref\": \"#/definitions/Path\" }]\n    },\n    \"MatchConditions\": {\n      \"type\": \"array\",\n      \"items\": { \"$ref\": \"#/definitions/MatchCondition\" },\n      \"minItems\": 1\n    },\n    \"OverlayOptions\": {\n      \"additionalProperties\": false,\n      \"type\": \"object\",\n      \"properties\": {\n        \"entry\": {\n          \"anyOf\": [{ \"const\": false }, { \"$ref\": \"#/definitions/Path\" }]\n        },\n        \"module\": {\n          \"anyOf\": [{ \"const\": false }, { \"$ref\": \"#/definitions/Path\" }]\n        },\n        \"sockIntegration\": {\n          \"anyOf\": [\n            { \"const\": false },\n            { \"enum\": [\"wds\", \"whm\", \"wps\"] },\n            { \"$ref\": \"#/definitions/Path\" }\n          ]\n        },\n        \"sockHost\": { \"type\": \"string\" },\n        \"sockPath\": { \"type\": \"string\" },\n        \"sockPort\": { \"type\": \"number\", \"minimum\": 0 },\n        \"useLegacyWDSSockets\": { \"type\": \"boolean\" }\n      }\n    },\n    \"Path\": { \"type\": \"string\", \"absolutePath\": true }\n  },\n  \"properties\": {\n    \"exclude\": {\n      \"anyOf\": [\n        { \"$ref\": \"#/definitions/MatchCondition\" },\n        { \"$ref\": \"#/definitions/MatchConditions\" }\n      ]\n    },\n    \"forceEnable\": { \"type\": \"boolean\" },\n    \"include\": {\n      \"anyOf\": [\n        { \"$ref\": \"#/definitions/MatchCondition\" },\n        { \"$ref\": \"#/definitions/MatchConditions\" }\n      ]\n    },\n    \"overlay\": {\n      \"anyOf\": [{ \"type\": \"boolean\" }, { \"$ref\": \"#/definitions/OverlayOptions\" }]\n    }\n  }\n}\n","const RuntimeGlobals = require('webpack/lib/RuntimeGlobals');\nconst RuntimeModule = require('webpack/lib/RuntimeModule');\nconst Template = require('webpack/lib/Template');\nconst { refreshGlobal } = require('../globals');\nconst getRefreshGlobal = require('../utils/getRefreshGlobal');\n\nclass ReactRefreshRuntimeModule extends RuntimeModule {\n  constructor() {\n    // Second argument is the `stage` for this runtime module -\n    // we'll use the same stage as Webpack's HMR runtime module for safety.\n    super('react refresh', 5);\n  }\n\n  /**\n   * @returns {string} runtime code\n   */\n  generate() {\n    const { runtimeTemplate } = this.compilation;\n    return Template.asString([\n      `${RuntimeGlobals.interceptModuleExecution}.push(${runtimeTemplate.basicFunction('options', [\n        `${runtimeTemplate.supportsConst() ? 'const' : 'var'} originalFactory = options.factory;`,\n        `options.factory = ${runtimeTemplate.basicFunction(\n          'moduleObject, moduleExports, webpackRequire',\n          [\n            `${refreshGlobal}.init();`,\n            'try {',\n            Template.indent(\n              'originalFactory.call(this, moduleObject, moduleExports, webpackRequire);'\n            ),\n            '} finally {',\n            Template.indent(`${refreshGlobal}.cleanup(options.id);`),\n            '}',\n          ]\n        )}`,\n      ])})`,\n      '',\n      getRefreshGlobal(runtimeTemplate),\n    ]);\n  }\n}\n\nmodule.exports = ReactRefreshRuntimeModule;\n"]}