{"version":3,"sources":["main.js","umd/history.production.min.js","umd/history.development.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n/* eslint-env node */\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./umd/history.production.min.js');\n} else {\n  module.exports = require('./umd/history.development.js');\n}\n","!function(t,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?n(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],n):n((t=\"undefined\"!=typeof globalThis?globalThis:t||self).HistoryLibrary={})}(this,(function(t){function n(){return(n=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t}).apply(this,arguments)}var e;t.Action=void 0,(e=t.Action||(t.Action={})).Pop=\"POP\",e.Push=\"PUSH\",e.Replace=\"REPLACE\";var r=\"beforeunload\",o=\"popstate\";function a(t,n,e){return Math.min(Math.max(t,n),e)}function i(t){t.preventDefault(),t.returnValue=\"\"}function c(){var t=[];return{get length(){return t.length},push:function(n){return t.push(n),function(){t=t.filter((function(t){return t!==n}))}},call:function(n){t.forEach((function(t){return t&&t(n)}))}}}function u(){return Math.random().toString(36).substr(2,8)}function l(t){var n=t.pathname,e=void 0===n?\"/\":n,r=t.search,o=void 0===r?\"\":r,a=t.hash,i=void 0===a?\"\":a;return o&&\"?\"!==o&&(e+=\"?\"===o.charAt(0)?o:\"?\"+o),i&&\"#\"!==i&&(e+=\"#\"===i.charAt(0)?i:\"#\"+i),e}function f(t){var n={};if(t){var e=t.indexOf(\"#\");e>=0&&(n.hash=t.substr(e),t=t.substr(0,e));var r=t.indexOf(\"?\");r>=0&&(n.search=t.substr(r),t=t.substr(0,r)),t&&(n.pathname=t)}return n}t.createBrowserHistory=function(e){void 0===e&&(e={});var a=e.window,s=void 0===a?document.defaultView:a,h=s.history;function p(){var t=s.location,n=t.pathname,e=t.search,r=t.hash,o=h.state||{};return[o.idx,{pathname:n,search:e,hash:r,state:o.usr||null,key:o.key||\"default\"}]}var v=null;s.addEventListener(o,(function(){if(v)A.call(v),v=null;else{var n=t.Action.Pop,e=p(),r=e[0],o=e[1];if(A.length){if(null!=r){var a=y-r;a&&(v={action:n,location:o,retry:function(){H(-1*a)}},H(a))}}else E(n)}}));var d=t.Action.Pop,g=p(),y=g[0],m=g[1],b=c(),A=c();function P(t){return\"string\"==typeof t?t:l(t)}function k(t,e){return void 0===e&&(e=null),n({pathname:m.pathname,hash:\"\",search:\"\"},\"string\"==typeof t?f(t):t,{state:e,key:u()})}function x(t,n){return[{usr:t.state,key:t.key,idx:n},P(t)]}function w(t,n,e){return!A.length||(A.call({action:t,location:n,retry:e}),!1)}function E(t){d=t;var n=p();y=n[0],m=n[1],b.call({action:d,location:m})}function H(t){h.go(t)}return null==y&&(y=0,h.replaceState(n({},h.state,{idx:y}),\"\")),{get action(){return d},get location(){return m},createHref:P,push:function n(e,r){var o=t.Action.Push,a=k(e,r);if(w(o,a,(function(){n(e,r)}))){var i=x(a,y+1),c=i[0],u=i[1];try{h.pushState(c,\"\",u)}catch(t){s.location.assign(u)}E(o)}},replace:function n(e,r){var o=t.Action.Replace,a=k(e,r);if(w(o,a,(function(){n(e,r)}))){var i=x(a,y),c=i[0],u=i[1];h.replaceState(c,\"\",u),E(o)}},go:H,back:function(){H(-1)},forward:function(){H(1)},listen:function(t){return b.push(t)},block:function(t){var n=A.push(t);return 1===A.length&&s.addEventListener(r,i),function(){n(),A.length||s.removeEventListener(r,i)}}}},t.createHashHistory=function(e){void 0===e&&(e={});var a=e.window,s=void 0===a?document.defaultView:a,h=s.history;function p(){var t=f(s.location.hash.substr(1)),n=t.pathname,e=void 0===n?\"/\":n,r=t.search,o=void 0===r?\"\":r,a=t.hash,i=void 0===a?\"\":a,c=h.state||{};return[c.idx,{pathname:e,search:o,hash:i,state:c.usr||null,key:c.key||\"default\"}]}var v=null;function d(){if(v)P.call(v),v=null;else{var n=t.Action.Pop,e=p(),r=e[0],o=e[1];if(P.length){if(null!=r){var a=m-r;a&&(v={action:n,location:o,retry:function(){L(-1*a)}},L(a))}}else H(n)}}s.addEventListener(o,d),s.addEventListener(\"hashchange\",(function(){l(p()[1])!==l(b)&&d()}));var g=t.Action.Pop,y=p(),m=y[0],b=y[1],A=c(),P=c();function k(t){return function(){var t=document.querySelector(\"base\"),n=\"\";if(t&&t.getAttribute(\"href\")){var e=s.location.href,r=e.indexOf(\"#\");n=-1===r?e:e.slice(0,r)}return n}()+\"#\"+(\"string\"==typeof t?t:l(t))}function x(t,e){return void 0===e&&(e=null),n({pathname:b.pathname,hash:\"\",search:\"\"},\"string\"==typeof t?f(t):t,{state:e,key:u()})}function w(t,n){return[{usr:t.state,key:t.key,idx:n},k(t)]}function E(t,n,e){return!P.length||(P.call({action:t,location:n,retry:e}),!1)}function H(t){g=t;var n=p();m=n[0],b=n[1],A.call({action:g,location:b})}function L(t){h.go(t)}return null==m&&(m=0,h.replaceState(n({},h.state,{idx:m}),\"\")),{get action(){return g},get location(){return b},createHref:k,push:function n(e,r){var o=t.Action.Push,a=x(e,r);if(E(o,a,(function(){n(e,r)}))){var i=w(a,m+1),c=i[0],u=i[1];try{h.pushState(c,\"\",u)}catch(t){s.location.assign(u)}H(o)}},replace:function n(e,r){var o=t.Action.Replace,a=x(e,r);if(E(o,a,(function(){n(e,r)}))){var i=w(a,m),c=i[0],u=i[1];h.replaceState(c,\"\",u),H(o)}},go:L,back:function(){L(-1)},forward:function(){L(1)},listen:function(t){return A.push(t)},block:function(t){var n=P.push(t);return 1===P.length&&s.addEventListener(r,i),function(){n(),P.length||s.removeEventListener(r,i)}}}},t.createMemoryHistory=function(e){void 0===e&&(e={});var r=e,o=r.initialEntries,i=void 0===o?[\"/\"]:o,s=r.initialIndex,h=i.map((function(t){return n({pathname:\"/\",search:\"\",hash:\"\",state:null,key:u()},\"string\"==typeof t?f(t):t)})),p=a(null==s?h.length-1:s,0,h.length-1),v=t.Action.Pop,d=h[p],g=c(),y=c();function m(t,e){return void 0===e&&(e=null),n({pathname:d.pathname,search:\"\",hash:\"\"},\"string\"==typeof t?f(t):t,{state:e,key:u()})}function b(t,n,e){return!y.length||(y.call({action:t,location:n,retry:e}),!1)}function A(t,n){v=t,d=n,g.call({action:v,location:d})}function P(n){var e=a(p+n,0,h.length-1),r=t.Action.Pop,o=h[e];b(r,o,(function(){P(n)}))&&(p=e,A(r,o))}return{get index(){return p},get action(){return v},get location(){return d},createHref:function(t){return\"string\"==typeof t?t:l(t)},push:function n(e,r){var o=t.Action.Push,a=m(e,r);b(o,a,(function(){n(e,r)}))&&(p+=1,h.splice(p,h.length,a),A(o,a))},replace:function n(e,r){var o=t.Action.Replace,a=m(e,r);b(o,a,(function(){n(e,r)}))&&(h[p]=a,A(o,a))},go:P,back:function(){P(-1)},forward:function(){P(1)},listen:function(t){return g.push(t)},block:function(t){return y.push(t)}}},t.createPath=l,t.parsePath=f,Object.defineProperty(t,\"__esModule\",{value:!0})}));\n//# sourceMappingURL=history.production.min.js.map\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.HistoryLibrary = {}));\n}(this, (function (exports) { \n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  /**\r\n   * Actions represent the type of change to a location value.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n   */\n  exports.Action = void 0;\n\n  (function (Action) {\n    /**\r\n     * A POP indicates a change to an arbitrary index in the history stack, such\r\n     * as a back or forward navigation. It does not describe the direction of the\r\n     * navigation, only that the current index changed.\r\n     *\r\n     * Note: This is the default action for newly created history objects.\r\n     */\n    Action[\"Pop\"] = \"POP\";\n    /**\r\n     * A PUSH indicates a new entry being added to the history stack, such as when\r\n     * a link is clicked and a new page loads. When this happens, all subsequent\r\n     * entries in the stack are lost.\r\n     */\n\n    Action[\"Push\"] = \"PUSH\";\n    /**\r\n     * A REPLACE indicates the entry at the current index in the history stack\r\n     * being replaced by a new one.\r\n     */\n\n    Action[\"Replace\"] = \"REPLACE\";\n  })(exports.Action || (exports.Action = {}));\n\n  var readOnly = function (obj) {\n    return Object.freeze(obj);\n  } ;\n\n  function warning(cond, message) {\n    if (!cond) {\n      // eslint-disable-next-line no-console\n      if (typeof console !== 'undefined') console.warn(message);\n\n      try {\n        // Welcome to debugging history!\n        //\n        // This error is thrown as a convenience so you can more easily\n        // find the source for a warning that appears in the console by\n        // enabling \"pause on exceptions\" in your JavaScript debugger.\n        throw new Error(message); // eslint-disable-next-line no-empty\n      } catch (e) {}\n    }\n  }\n\n  var BeforeUnloadEventType = 'beforeunload';\n  var HashChangeEventType = 'hashchange';\n  var PopStateEventType = 'popstate';\n  /**\r\n   * Browser history stores the location in regular URLs. This is the standard for\r\n   * most web apps, but it requires some configuration on the server to ensure you\r\n   * serve the same app at multiple URLs.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n   */\n\n  function createBrowserHistory(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        _options$window = _options.window,\n        window = _options$window === void 0 ? document.defaultView : _options$window;\n    var globalHistory = window.history;\n\n    function getIndexAndLocation() {\n      var _window$location = window.location,\n          pathname = _window$location.pathname,\n          search = _window$location.search,\n          hash = _window$location.hash;\n      var state = globalHistory.state || {};\n      return [state.idx, readOnly({\n        pathname: pathname,\n        search: search,\n        hash: hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })];\n    }\n\n    var blockedPopTx = null;\n\n    function handlePop() {\n      if (blockedPopTx) {\n        blockers.call(blockedPopTx);\n        blockedPopTx = null;\n      } else {\n        var nextAction = exports.Action.Pop;\n\n        var _getIndexAndLocation = getIndexAndLocation(),\n            nextIndex = _getIndexAndLocation[0],\n            nextLocation = _getIndexAndLocation[1];\n\n        if (blockers.length) {\n          if (nextIndex != null) {\n            var delta = index - nextIndex;\n\n            if (delta) {\n              // Revert the POP\n              blockedPopTx = {\n                action: nextAction,\n                location: nextLocation,\n                retry: function retry() {\n                  go(delta * -1);\n                }\n              };\n              go(delta);\n            }\n          } else {\n            // Trying to POP to a location with no index. We did not create\n            // this location, so we can't effectively block the navigation.\n            warning(false, // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better what\n            // is going on and how to avoid it.\n            \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") ;\n          }\n        } else {\n          applyTx(nextAction);\n        }\n      }\n    }\n\n    window.addEventListener(PopStateEventType, handlePop);\n    var action = exports.Action.Pop;\n\n    var _getIndexAndLocation2 = getIndexAndLocation(),\n        index = _getIndexAndLocation2[0],\n        location = _getIndexAndLocation2[1];\n\n    var listeners = createEvents();\n    var blockers = createEvents();\n\n    if (index == null) {\n      index = 0;\n      globalHistory.replaceState(_extends({}, globalHistory.state, {\n        idx: index\n      }), '');\n    }\n\n    function createHref(to) {\n      return typeof to === 'string' ? to : createPath(to);\n    } // state defaults to `null` because `window.history.state` does\n\n\n    function getNextLocation(to, state) {\n      if (state === void 0) {\n        state = null;\n      }\n\n      return readOnly(_extends({\n        pathname: location.pathname,\n        hash: '',\n        search: ''\n      }, typeof to === 'string' ? parsePath(to) : to, {\n        state: state,\n        key: createKey()\n      }));\n    }\n\n    function getHistoryStateAndUrl(nextLocation, index) {\n      return [{\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      }, createHref(nextLocation)];\n    }\n\n    function allowTx(action, location, retry) {\n      return !blockers.length || (blockers.call({\n        action: action,\n        location: location,\n        retry: retry\n      }), false);\n    }\n\n    function applyTx(nextAction) {\n      action = nextAction;\n\n      var _getIndexAndLocation3 = getIndexAndLocation();\n\n      index = _getIndexAndLocation3[0];\n      location = _getIndexAndLocation3[1];\n      listeners.call({\n        action: action,\n        location: location\n      });\n    }\n\n    function push(to, state) {\n      var nextAction = exports.Action.Push;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        push(to, state);\n      }\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n            historyState = _getHistoryStateAndUr[0],\n            url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n        // try...catch because iOS limits us to 100 pushState calls :/\n\n\n        try {\n          globalHistory.pushState(historyState, '', url);\n        } catch (error) {\n          // They are going to lose state here, but there is no real\n          // way to warn them about it since the page will refresh...\n          window.location.assign(url);\n        }\n\n        applyTx(nextAction);\n      }\n    }\n\n    function replace(to, state) {\n      var nextAction = exports.Action.Replace;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        replace(to, state);\n      }\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n            historyState = _getHistoryStateAndUr2[0],\n            url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n        globalHistory.replaceState(historyState, '', url);\n        applyTx(nextAction);\n      }\n    }\n\n    function go(delta) {\n      globalHistory.go(delta);\n    }\n\n    var history = {\n      get action() {\n        return action;\n      },\n\n      get location() {\n        return location;\n      },\n\n      createHref: createHref,\n      push: push,\n      replace: replace,\n      go: go,\n      back: function back() {\n        go(-1);\n      },\n      forward: function forward() {\n        go(1);\n      },\n      listen: function listen(listener) {\n        return listeners.push(listener);\n      },\n      block: function block(blocker) {\n        var unblock = blockers.push(blocker);\n\n        if (blockers.length === 1) {\n          window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n\n        return function () {\n          unblock(); // Remove the beforeunload listener so the document may\n          // still be salvageable in the pagehide event.\n          // See https://html.spec.whatwg.org/#unloading-documents\n\n          if (!blockers.length) {\n            window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n          }\n        };\n      }\n    };\n    return history;\n  }\n  /**\r\n   * Hash history stores the location in window.location.hash. This makes it ideal\r\n   * for situations where you don't want to send the location to the server for\r\n   * some reason, either because you do cannot configure it or the URL space is\r\n   * reserved for something else.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n   */\n\n  function createHashHistory(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options2 = options,\n        _options2$window = _options2.window,\n        window = _options2$window === void 0 ? document.defaultView : _options2$window;\n    var globalHistory = window.history;\n\n    function getIndexAndLocation() {\n      var _parsePath = parsePath(window.location.hash.substr(1)),\n          _parsePath$pathname = _parsePath.pathname,\n          pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n          _parsePath$search = _parsePath.search,\n          search = _parsePath$search === void 0 ? '' : _parsePath$search,\n          _parsePath$hash = _parsePath.hash,\n          hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n      var state = globalHistory.state || {};\n      return [state.idx, readOnly({\n        pathname: pathname,\n        search: search,\n        hash: hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })];\n    }\n\n    var blockedPopTx = null;\n\n    function handlePop() {\n      if (blockedPopTx) {\n        blockers.call(blockedPopTx);\n        blockedPopTx = null;\n      } else {\n        var nextAction = exports.Action.Pop;\n\n        var _getIndexAndLocation4 = getIndexAndLocation(),\n            nextIndex = _getIndexAndLocation4[0],\n            nextLocation = _getIndexAndLocation4[1];\n\n        if (blockers.length) {\n          if (nextIndex != null) {\n            var delta = index - nextIndex;\n\n            if (delta) {\n              // Revert the POP\n              blockedPopTx = {\n                action: nextAction,\n                location: nextLocation,\n                retry: function retry() {\n                  go(delta * -1);\n                }\n              };\n              go(delta);\n            }\n          } else {\n            // Trying to POP to a location with no index. We did not create\n            // this location, so we can't effectively block the navigation.\n            warning(false, // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better\n            // what is going on and how to avoid it.\n            \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") ;\n          }\n        } else {\n          applyTx(nextAction);\n        }\n      }\n    }\n\n    window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n    // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n    window.addEventListener(HashChangeEventType, function () {\n      var _getIndexAndLocation5 = getIndexAndLocation(),\n          nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n      if (createPath(nextLocation) !== createPath(location)) {\n        handlePop();\n      }\n    });\n    var action = exports.Action.Pop;\n\n    var _getIndexAndLocation6 = getIndexAndLocation(),\n        index = _getIndexAndLocation6[0],\n        location = _getIndexAndLocation6[1];\n\n    var listeners = createEvents();\n    var blockers = createEvents();\n\n    if (index == null) {\n      index = 0;\n      globalHistory.replaceState(_extends({}, globalHistory.state, {\n        idx: index\n      }), '');\n    }\n\n    function getBaseHref() {\n      var base = document.querySelector('base');\n      var href = '';\n\n      if (base && base.getAttribute('href')) {\n        var url = window.location.href;\n        var hashIndex = url.indexOf('#');\n        href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n      }\n\n      return href;\n    }\n\n    function createHref(to) {\n      return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n    }\n\n    function getNextLocation(to, state) {\n      if (state === void 0) {\n        state = null;\n      }\n\n      return readOnly(_extends({\n        pathname: location.pathname,\n        hash: '',\n        search: ''\n      }, typeof to === 'string' ? parsePath(to) : to, {\n        state: state,\n        key: createKey()\n      }));\n    }\n\n    function getHistoryStateAndUrl(nextLocation, index) {\n      return [{\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      }, createHref(nextLocation)];\n    }\n\n    function allowTx(action, location, retry) {\n      return !blockers.length || (blockers.call({\n        action: action,\n        location: location,\n        retry: retry\n      }), false);\n    }\n\n    function applyTx(nextAction) {\n      action = nextAction;\n\n      var _getIndexAndLocation7 = getIndexAndLocation();\n\n      index = _getIndexAndLocation7[0];\n      location = _getIndexAndLocation7[1];\n      listeners.call({\n        action: action,\n        location: location\n      });\n    }\n\n    function push(to, state) {\n      var nextAction = exports.Action.Push;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        push(to, state);\n      }\n\n      warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") ;\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n            historyState = _getHistoryStateAndUr3[0],\n            url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n        // try...catch because iOS limits us to 100 pushState calls :/\n\n\n        try {\n          globalHistory.pushState(historyState, '', url);\n        } catch (error) {\n          // They are going to lose state here, but there is no real\n          // way to warn them about it since the page will refresh...\n          window.location.assign(url);\n        }\n\n        applyTx(nextAction);\n      }\n    }\n\n    function replace(to, state) {\n      var nextAction = exports.Action.Replace;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        replace(to, state);\n      }\n\n      warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") ;\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n            historyState = _getHistoryStateAndUr4[0],\n            url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n        globalHistory.replaceState(historyState, '', url);\n        applyTx(nextAction);\n      }\n    }\n\n    function go(delta) {\n      globalHistory.go(delta);\n    }\n\n    var history = {\n      get action() {\n        return action;\n      },\n\n      get location() {\n        return location;\n      },\n\n      createHref: createHref,\n      push: push,\n      replace: replace,\n      go: go,\n      back: function back() {\n        go(-1);\n      },\n      forward: function forward() {\n        go(1);\n      },\n      listen: function listen(listener) {\n        return listeners.push(listener);\n      },\n      block: function block(blocker) {\n        var unblock = blockers.push(blocker);\n\n        if (blockers.length === 1) {\n          window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n\n        return function () {\n          unblock(); // Remove the beforeunload listener so the document may\n          // still be salvageable in the pagehide event.\n          // See https://html.spec.whatwg.org/#unloading-documents\n\n          if (!blockers.length) {\n            window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n          }\n        };\n      }\n    };\n    return history;\n  }\n  /**\r\n   * Memory history stores the current location in memory. It is designed for use\r\n   * in stateful non-browser environments like tests and React Native.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n   */\n\n  function createMemoryHistory(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options3 = options,\n        _options3$initialEntr = _options3.initialEntries,\n        initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n        initialIndex = _options3.initialIndex;\n    var entries = initialEntries.map(function (entry) {\n      var location = readOnly(_extends({\n        pathname: '/',\n        search: '',\n        hash: '',\n        state: null,\n        key: createKey()\n      }, typeof entry === 'string' ? parsePath(entry) : entry));\n      warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") ;\n      return location;\n    });\n    var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n    var action = exports.Action.Pop;\n    var location = entries[index];\n    var listeners = createEvents();\n    var blockers = createEvents();\n\n    function createHref(to) {\n      return typeof to === 'string' ? to : createPath(to);\n    }\n\n    function getNextLocation(to, state) {\n      if (state === void 0) {\n        state = null;\n      }\n\n      return readOnly(_extends({\n        pathname: location.pathname,\n        search: '',\n        hash: ''\n      }, typeof to === 'string' ? parsePath(to) : to, {\n        state: state,\n        key: createKey()\n      }));\n    }\n\n    function allowTx(action, location, retry) {\n      return !blockers.length || (blockers.call({\n        action: action,\n        location: location,\n        retry: retry\n      }), false);\n    }\n\n    function applyTx(nextAction, nextLocation) {\n      action = nextAction;\n      location = nextLocation;\n      listeners.call({\n        action: action,\n        location: location\n      });\n    }\n\n    function push(to, state) {\n      var nextAction = exports.Action.Push;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        push(to, state);\n      }\n\n      warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") ;\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        index += 1;\n        entries.splice(index, entries.length, nextLocation);\n        applyTx(nextAction, nextLocation);\n      }\n    }\n\n    function replace(to, state) {\n      var nextAction = exports.Action.Replace;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        replace(to, state);\n      }\n\n      warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") ;\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        entries[index] = nextLocation;\n        applyTx(nextAction, nextLocation);\n      }\n    }\n\n    function go(delta) {\n      var nextIndex = clamp(index + delta, 0, entries.length - 1);\n      var nextAction = exports.Action.Pop;\n      var nextLocation = entries[nextIndex];\n\n      function retry() {\n        go(delta);\n      }\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        index = nextIndex;\n        applyTx(nextAction, nextLocation);\n      }\n    }\n\n    var history = {\n      get index() {\n        return index;\n      },\n\n      get action() {\n        return action;\n      },\n\n      get location() {\n        return location;\n      },\n\n      createHref: createHref,\n      push: push,\n      replace: replace,\n      go: go,\n      back: function back() {\n        go(-1);\n      },\n      forward: function forward() {\n        go(1);\n      },\n      listen: function listen(listener) {\n        return listeners.push(listener);\n      },\n      block: function block(blocker) {\n        return blockers.push(blocker);\n      }\n    };\n    return history;\n  } ////////////////////////////////////////////////////////////////////////////////\n  // UTILS\n  ////////////////////////////////////////////////////////////////////////////////\n\n  function clamp(n, lowerBound, upperBound) {\n    return Math.min(Math.max(n, lowerBound), upperBound);\n  }\n\n  function promptBeforeUnload(event) {\n    // Cancel the event.\n    event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n    event.returnValue = '';\n  }\n\n  function createEvents() {\n    var handlers = [];\n    return {\n      get length() {\n        return handlers.length;\n      },\n\n      push: function push(fn) {\n        handlers.push(fn);\n        return function () {\n          handlers = handlers.filter(function (handler) {\n            return handler !== fn;\n          });\n        };\n      },\n      call: function call(arg) {\n        handlers.forEach(function (fn) {\n          return fn && fn(arg);\n        });\n      }\n    };\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, 8);\n  }\n  /**\r\n   * Creates a string URL path from the given pathname, search, and hash components.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n   */\n\n\n  function createPath(_ref) {\n    var _ref$pathname = _ref.pathname,\n        pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n        _ref$search = _ref.search,\n        search = _ref$search === void 0 ? '' : _ref$search,\n        _ref$hash = _ref.hash,\n        hash = _ref$hash === void 0 ? '' : _ref$hash;\n    if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n    if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n    return pathname;\n  }\n  /**\r\n   * Parses a string URL path into its separate pathname, search, and hash components.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n   */\n\n  function parsePath(path) {\n    var parsedPath = {};\n\n    if (path) {\n      var hashIndex = path.indexOf('#');\n\n      if (hashIndex >= 0) {\n        parsedPath.hash = path.substr(hashIndex);\n        path = path.substr(0, hashIndex);\n      }\n\n      var searchIndex = path.indexOf('?');\n\n      if (searchIndex >= 0) {\n        parsedPath.search = path.substr(searchIndex);\n        path = path.substr(0, searchIndex);\n      }\n\n      if (path) {\n        parsedPath.pathname = path;\n      }\n    }\n\n    return parsedPath;\n  }\n\n  exports.createBrowserHistory = createBrowserHistory;\n  exports.createHashHistory = createHashHistory;\n  exports.createMemoryHistory = createMemoryHistory;\n  exports.createPath = createPath;\n  exports.parsePath = parsePath;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=history.development.js.map\n"]}