{"version":3,"sources":["index.js","runtime/catchError.js","constants.js","runtime/debounceRendering.js","runtime/vnode.js","runtime/vnodesForComponent.js","runtime/unmount.js","computeKey.js","runtime/signaturesForType.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA,AENA;ADIA,AFMA,ACHA,AENA;ADIA,AFMA,ACHA,AENA;ADIA,AFMA,ACHA,AENA,ACHA;AFOA,AFMA,ACHA,AENA,ACHA;AFOA,AFMA,ACHA,AENA,ACHA;AFOA,AFMA,ACHA,AENA,ACHA,ACHA;AHUA,AFMA,ACHA,AENA,ACHA,ACHA;AHUA,AFMA,ACHA,AENA,ACHA,ACHA;AHUA,AFMA,ACHA,AENA,AGTA,AFMA,ACHA;AHUA,AFMA,AGTA,AGTA,AFMA;AJaA,AGTA,AGTA,AFMA;AGRA,APqBA,AGTA,AGTA,AFMA;AGRA,APqBA,AGTA,AGTA,AFMA;AGRA,APqBA,AGTA,AGTA,AFMA;AGRA,APqBA,AGTA,AKfA,AFMA,AFMA;AGRA,APqBA,AGTA,AKfA,AFMA,AFMA;AGRA,APqBA,AGTA,AKfA,AFMA,AFMA;AGRA,APqBA,AGTA,AGTA,AFMA;AGRA,APqBA,AGTA,AGTA,AFMA;AGRA,APqBA,AMlBA,AFMA;AGRA,APqBA,AMlBA,AFMA;AGRA,APqBA,AMlBA,AFMA;AGRA,APqBA,AMlBA,AFMA;AGRA,APqBA,AMlBA,AFMA;AGRA,APqBA,AMlBA,AFMA;AGRA,APqBA,AMlBA,AFMA;AGRA,APqBA,AMlBA,AFMA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA,AIZA;AGRA,APqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// Options for Preact.\nvar __TEMP__ = require('./runtime/catchError');\nvar __TEMP__ = require('./runtime/debounceRendering');\nvar __TEMP__ = require('./runtime/vnode');\nvar __TEMP__ = require('./runtime/unmount');\n\nvar __TEMP__ = require('preact');var Component = __TEMP__['Component'];\n\nvar __TEMP__ = require('./constants');var VNODE_COMPONENT = __TEMP__['VNODE_COMPONENT'];var NAMESPACE = __TEMP__['NAMESPACE'];var HOOKS_LIST = __TEMP__['HOOKS_LIST'];var EFFECTS_LIST = __TEMP__['EFFECTS_LIST'];var COMPONENT_HOOKS = __TEMP__['COMPONENT_HOOKS'];var VNODE_DOM = __TEMP__['VNODE_DOM'];var VNODE_CHILDREN = __TEMP__['VNODE_CHILDREN'];var HOOK_ARGS = __TEMP__['HOOK_ARGS'];var HOOK_VALUE = __TEMP__['HOOK_VALUE'];var HOOK_CLEANUP = __TEMP__['HOOK_CLEANUP'];\n\n\n\n\n\n\n\n\n\n\n\nvar __TEMP__ = require('./computeKey');var computeKey = __TEMP__['computeKey'];\nvar __TEMP__ = require('./runtime/vnodesForComponent');var vnodesForComponent = __TEMP__['vnodesForComponent'];var mappedVNodes = __TEMP__['mappedVNodes'];\nvar __TEMP__ = require('./runtime/signaturesForType');var signaturesForType = __TEMP__['signaturesForType'];\n\nlet typesById = new Map();\nlet pendingUpdates = [];\n\nfunction sign(type, key, forceReset, getCustomHooks, status) {\n  if (type) {\n    let signature = signaturesForType.get(type);\n    if (status === 'begin') {\n      signaturesForType.set(type, {\n        type,\n        key,\n        forceReset,\n        getCustomHooks: getCustomHooks || (() => []),\n      });\n\n      return 'needsHooks';\n    } else if (status === 'needsHooks') {\n      signature.fullKey = computeKey(signature);\n    }\n  }\n}\n\nfunction replaceComponent(OldType, NewType, resetHookState) {\n  const vnodes = vnodesForComponent.get(OldType);\n  if (!vnodes) return;\n\n  // migrate the list to our new constructor reference\n  vnodesForComponent.delete(OldType);\n  vnodesForComponent.set(NewType, vnodes);\n\n  mappedVNodes.set(OldType, NewType);\n\n  pendingUpdates = pendingUpdates.filter(p => p[0] !== OldType);\n\n  vnodes.forEach(vnode => {\n    // update the type in-place to reference the new component\n    vnode.type = NewType;\n\n    if (vnode[VNODE_COMPONENT]) {\n      vnode[VNODE_COMPONENT].constructor = vnode.type;\n\n      try {\n        if (vnode[VNODE_COMPONENT] instanceof OldType) {\n          const oldInst = vnode[VNODE_COMPONENT];\n\n          const newInst = new NewType(\n            vnode[VNODE_COMPONENT].props,\n            vnode[VNODE_COMPONENT].context\n          );\n\n          vnode[VNODE_COMPONENT] = newInst;\n          // copy old properties onto the new instance.\n          //   - Objects (including refs) in the new instance are updated with their old values\n          //   - Missing or null properties are restored to their old values\n          //   - Updated Functions are not reverted\n          //   - Scalars are copied\n          for (let i in oldInst) {\n            const type = typeof oldInst[i];\n            if (!(i in newInst)) {\n              newInst[i] = oldInst[i];\n            } else if (type !== 'function' && typeof newInst[i] === type) {\n              if (\n                type === 'object' &&\n                newInst[i] != null &&\n                newInst[i].constructor === oldInst[i].constructor\n              ) {\n                Object.assign(newInst[i], oldInst[i]);\n              } else {\n                newInst[i] = oldInst[i];\n              }\n            }\n          }\n        }\n      } catch (e) {\n        /* Functional component */\n        vnode[VNODE_COMPONENT].constructor = NewType;\n      }\n\n      if (resetHookState) {\n        if (\n          vnode[VNODE_COMPONENT][COMPONENT_HOOKS] &&\n          vnode[VNODE_COMPONENT][COMPONENT_HOOKS][HOOKS_LIST] &&\n          vnode[VNODE_COMPONENT][COMPONENT_HOOKS][HOOKS_LIST].length\n        ) {\n          vnode[VNODE_COMPONENT][COMPONENT_HOOKS][HOOKS_LIST].forEach(\n            possibleEffect => {\n              if (\n                possibleEffect[HOOK_CLEANUP] &&\n                typeof possibleEffect[HOOK_CLEANUP] === 'function'\n              ) {\n                possibleEffect[HOOK_CLEANUP]();\n              } else if (\n                possibleEffect[HOOK_ARGS] &&\n                possibleEffect[HOOK_VALUE] &&\n                Object.keys(possibleEffect).length === 3\n              ) {\n                const cleanupKey = Object.keys(possibleEffect).find(\n                  key => key !== HOOK_ARGS && key !== HOOK_VALUE\n                );\n                if (\n                  cleanupKey &&\n                  typeof possibleEffect[cleanupKey] == 'function'\n                )\n                  possibleEffect[cleanupKey]();\n              }\n            }\n          );\n        }\n\n        vnode[VNODE_COMPONENT][COMPONENT_HOOKS] = {\n          [HOOKS_LIST]: [],\n          [EFFECTS_LIST]: [],\n        };\n      } else if (\n        vnode[VNODE_COMPONENT][COMPONENT_HOOKS] &&\n        vnode[VNODE_COMPONENT][COMPONENT_HOOKS][HOOKS_LIST] &&\n        vnode[VNODE_COMPONENT][COMPONENT_HOOKS][HOOKS_LIST].length\n      ) {\n        vnode[VNODE_COMPONENT][COMPONENT_HOOKS][HOOKS_LIST].forEach(\n          possibleEffect => {\n            if (\n              possibleEffect[HOOK_CLEANUP] &&\n              typeof possibleEffect[HOOK_CLEANUP] === 'function'\n            ) {\n              possibleEffect[HOOK_CLEANUP]();\n            } else if (\n              possibleEffect[HOOK_ARGS] &&\n              possibleEffect[HOOK_VALUE] &&\n              Object.keys(possibleEffect).length === 3\n            ) {\n              const cleanupKey = Object.keys(possibleEffect).find(\n                key => key !== HOOK_ARGS && key !== HOOK_VALUE\n              );\n              if (cleanupKey && typeof possibleEffect[cleanupKey] == 'function')\n                possibleEffect[cleanupKey]();\n            }\n          }\n        );\n\n        vnode[VNODE_COMPONENT][COMPONENT_HOOKS][HOOKS_LIST].forEach(hook => {\n          if (hook.__H && Array.isArray(hook.__H)) {\n            hook.__H = undefined;\n          }\n        });\n      }\n\n      Component.prototype.forceUpdate.call(vnode[VNODE_COMPONENT]);\n    }\n  });\n}\n\nself[NAMESPACE] = {\n  getSignature: type => signaturesForType.get(type),\n  register: (type, id) => {\n    if (typeof type !== 'function') return;\n\n    if (typesById.has(id)) {\n      const existing = typesById.get(id);\n      if (existing !== type) {\n        pendingUpdates.push([existing, type]);\n        typesById.set(id, type);\n      }\n    } else {\n      typesById.set(id, type);\n    }\n\n    if (!signaturesForType.has(type)) {\n      signaturesForType.set(type, {\n        getCustomHooks: () => [],\n        type,\n      });\n    }\n  },\n  getPendingUpdates: () => pendingUpdates,\n  flush: () => {\n    pendingUpdates = [];\n  },\n  replaceComponent,\n  sign,\n  computeKey,\n};\n","var __TEMP__ = require('preact');var options = __TEMP__['options'];\nvar __TEMP__ = require('../constants');var CATCH_ERROR_OPTION = __TEMP__['CATCH_ERROR_OPTION'];var COMPONENT_DIRTY = __TEMP__['COMPONENT_DIRTY'];var VNODE_COMPONENT = __TEMP__['VNODE_COMPONENT'];\n\n\n\n\n\nconst oldCatchError = options[CATCH_ERROR_OPTION];\noptions[CATCH_ERROR_OPTION] = (error, vnode, oldVNode) => {\n  if (vnode[VNODE_COMPONENT] && vnode[VNODE_COMPONENT][COMPONENT_DIRTY]) {\n    vnode[VNODE_COMPONENT][COMPONENT_DIRTY] = false;\n  }\n\n  if (oldCatchError) oldCatchError(error, vnode, oldVNode);\n};\n","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var VNODE_COMPONENT = exports.VNODE_COMPONENT = '__c';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var NAMESPACE = exports.NAMESPACE = '__PREFRESH__';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var COMPONENT_HOOKS = exports.COMPONENT_HOOKS = '__H';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var HOOKS_LIST = exports.HOOKS_LIST = '__';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var EFFECTS_LIST = exports.EFFECTS_LIST = '__h';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RERENDER_COUNT = exports.RERENDER_COUNT = '__r';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var CATCH_ERROR_OPTION = exports.CATCH_ERROR_OPTION = '__e';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var COMPONENT_DIRTY = exports.COMPONENT_DIRTY = '__d';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var VNODE_DOM = exports.VNODE_DOM = '__e';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var VNODE_CHILDREN = exports.VNODE_CHILDREN = '__k';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var HOOK_VALUE = exports.HOOK_VALUE = '__';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var HOOK_ARGS = exports.HOOK_ARGS = '__H';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var HOOK_CLEANUP = exports.HOOK_CLEANUP = '__c';\n","var __TEMP__ = require('preact');var options = __TEMP__['options'];\n\nvar __TEMP__ = require('../constants');var RERENDER_COUNT = __TEMP__['RERENDER_COUNT'];\n\nconst defer =\n  typeof Promise == 'function'\n    ? Promise.prototype.then.bind(Promise.resolve())\n    : setTimeout;\n\noptions.debounceRendering = process => {\n  defer(() => {\n    try {\n      process();\n    } catch (e) {\n      process[RERENDER_COUNT] = 0;\n      throw e;\n    }\n  });\n};\n","var __TEMP__ = require('preact');var options = __TEMP__['options'];\nvar __TEMP__ = require('./vnodesForComponent');var vnodesForComponent = __TEMP__['vnodesForComponent'];var mappedVNodes = __TEMP__['mappedVNodes'];\nvar __TEMP__ = require('../constants');var VNODE_COMPONENT = __TEMP__['VNODE_COMPONENT'];\n\nconst getMappedVnode = type => {\n  if (mappedVNodes.has(type)) {\n    return getMappedVnode(mappedVNodes.get(type));\n  }\n\n  return type;\n};\n\nconst oldVnode = options.vnode;\noptions.vnode = vnode => {\n  if (vnode && typeof vnode.type === 'function') {\n    const vnodes = vnodesForComponent.get(vnode.type);\n    if (!vnodes) {\n      vnodesForComponent.set(vnode.type, [vnode]);\n    } else {\n      vnodes.push(vnode);\n    }\n\n    const foundType = getMappedVnode(vnode.type);\n    if (foundType !== vnode.type) {\n      const vnodes = vnodesForComponent.get(foundType);\n      if (!vnodes) {\n        vnodesForComponent.set(foundType, [vnode]);\n      } else {\n        vnodes.push(vnode);\n      }\n    }\n\n    vnode.type = foundType;\n    if (\n      vnode[VNODE_COMPONENT] &&\n      'prototype' in vnode.type &&\n      vnode.type.prototype.render\n    ) {\n      vnode[VNODE_COMPONENT].constructor = vnode.type;\n    }\n  }\n\n  if (oldVnode) oldVnode(vnode);\n};\n","// all vnodes referencing a given constructor\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var vnodesForComponent = exports.vnodesForComponent = new WeakMap();\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var mappedVNodes = exports.mappedVNodes = new WeakMap();\n","var __TEMP__ = require('preact');var options = __TEMP__['options'];\nvar __TEMP__ = require('./vnodesForComponent');var vnodesForComponent = __TEMP__['vnodesForComponent'];\n\nconst oldUnmount = options.unmount;\noptions.unmount = vnode => {\n  const type = (vnode || {}).type;\n  if (typeof type === 'function' && vnodesForComponent.has(type)) {\n    const vnodes = vnodesForComponent.get(type);\n    if (vnodes) {\n      const index = vnodes.indexOf(vnode);\n      if (index !== -1) {\n        vnodes.splice(index, 1);\n      }\n    }\n  }\n\n  if (oldUnmount) oldUnmount(vnode);\n};\n","var __TEMP__ = require('./runtime/signaturesForType');var signaturesForType = __TEMP__['signaturesForType'];\n\n/**\n *\n * This part has been vendored from \"react-refresh\"\n * https://github.com/facebook/react/blob/master/packages/react-refresh/src/ReactFreshRuntime.js#L83\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var computeKey = exports.computeKey = signature => {\n  let fullKey = signature.key;\n  let hooks;\n\n  try {\n    hooks = signature.getCustomHooks();\n  } catch (err) {\n    signature.forceReset = true;\n    return fullKey;\n  }\n\n  for (let i = 0; i < hooks.length; i++) {\n    const hook = hooks[i];\n    if (typeof hook !== 'function') {\n      signature.forceReset = true;\n      return fullKey;\n    }\n\n    const nestedHookSignature = signaturesForType.get(hook);\n    if (nestedHookSignature === undefined) continue;\n\n    const nestedHookKey = computeKey(nestedHookSignature);\n    if (nestedHookSignature.forceReset) signature.forceReset = true;\n\n    fullKey += '\\n---\\n' + nestedHookKey;\n  }\n\n  return fullKey;\n};\n","// Signatures for functional components and custom hooks.\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var signaturesForType = exports.signaturesForType = new WeakMap();\n"]}