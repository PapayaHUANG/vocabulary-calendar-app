{"version":3,"sources":["runtime.esm.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('@tarojs/shared');var isFunction = __TEMP__['isFunction'];var isUndefined = __TEMP__['isUndefined'];var isObject = __TEMP__['isObject'];var warn = __TEMP__['warn'];var isArray = __TEMP__['isArray'];var toCamelCase = __TEMP__['toCamelCase'];var noop = __TEMP__['noop'];var ensure = __TEMP__['ensure'];var toDashed = __TEMP__['toDashed'];var isString = __TEMP__['isString'];var EMPTY_OBJ = __TEMP__['EMPTY_OBJ'];var internalComponents = __TEMP__['internalComponents'];var controlledComponent = __TEMP__['controlledComponent'];var defaultReconciler = __TEMP__['defaultReconciler'];\nvar __TEMP__ = require('inversify');var injectable = __TEMP__['injectable'];var inject = __TEMP__['inject'];var ContainerModule = __TEMP__['ContainerModule'];var optional = __TEMP__['optional'];var multiInject = __TEMP__['multiInject'];var Container = __TEMP__['Container'];\n\n/*! *****************************************************************************\nCopyright (C) Microsoft. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\nif (process.env.TARO_ENV === 'h5') {\n  require('reflect-metadata');\n} else {\n  // var Reflect;\n  (function (Reflect) {\n      // Metadata Proposal\n      // https://rbuckton.github.io/reflect-metadata/\n      (function (factory) {\n          // var root = typeof global === \"object\" ? global :\n          //     typeof self === \"object\" ? self :\n          //         typeof this === \"object\" ? this :\n          //             Function(\"return this;\")();\n          var exporter = makeExporter(Reflect);\n          // if (typeof root.Reflect === \"undefined\") {\n          //     root.Reflect = Reflect;\n          // }\n          // else {\n          //     exporter = makeExporter(root.Reflect, exporter);\n          // }\n          factory(exporter);\n          function makeExporter(target, previous) {\n              return function (key, value) {\n                  if (!isFunction(target[key])) {\n                      Object.defineProperty(target, key, { configurable: true, writable: true, value: value });\n                  }\n                  if (previous)\n                      previous(key, value);\n              };\n          }\n      })(function (exporter) {\n          var hasOwn = Object.prototype.hasOwnProperty;\n          // feature test for Symbol support\n          var supportsSymbol = isFunction(Symbol);\n          var toPrimitiveSymbol = supportsSymbol && !isUndefined(Symbol.toPrimitive) ? Symbol.toPrimitive : \"@@toPrimitive\";\n          var iteratorSymbol = supportsSymbol && !isUndefined(Symbol.iterator) ? Symbol.iterator : \"@@iterator\";\n          var supportsCreate = isFunction(Object.create); // feature test for Object.create support\n          var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support\n          var downLevel = !supportsCreate && !supportsProto;\n          var HashMap = {\n              // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\n              create: supportsCreate\n                  ? function () { return MakeDictionary(Object.create(null)); }\n                  : supportsProto\n                      ? function () { return MakeDictionary({ __proto__: null }); }\n                      : function () { return MakeDictionary({}); },\n              has: downLevel\n                  ? function (map, key) { return hasOwn.call(map, key); }\n                  : function (map, key) { return key in map; },\n              get: downLevel\n                  ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }\n                  : function (map, key) { return map[key]; },\n          };\n          // Load global or shim versions of Map, Set, and WeakMap\n          var functionPrototype = Object.getPrototypeOf(Function);\n          var _Map = Map;\n          var _Set = Set;\n          var _WeakMap = isFunction(WeakMap) ? WeakMap : CreateWeakMapPolyfill();\n          // [[Metadata]] internal slot\n          // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\n          var Metadata = new _WeakMap();\n          /**\n           * Applies a set of decorators to a property of a target object.\n           * @param decorators An array of decorators.\n           * @param target The target object.\n           * @param propertyKey (Optional) The property key to decorate.\n           * @param attributes (Optional) The property descriptor for the target key.\n           * @remarks Decorators are applied in reverse order.\n           * @example\n           *\n           *     class Example {\n           *         // property declarations are not part of ES6, though they are valid in TypeScript:\n           *         // static staticProperty;\n           *         // property;\n           *\n           *         constructor(p) { }\n           *         static staticMethod(p) { }\n           *         method(p) { }\n           *     }\n           *\n           *     // constructor\n           *     Example = Reflect.decorate(decoratorsArray, Example);\n           *\n           *     // property (on constructor)\n           *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\n           *\n           *     // property (on prototype)\n           *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\n           *\n           *     // method (on constructor)\n           *     Object.defineProperty(Example, \"staticMethod\",\n           *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\n           *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\n           *\n           *     // method (on prototype)\n           *     Object.defineProperty(Example.prototype, \"method\",\n           *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\n           *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\n           *\n           */\n          function decorate(decorators, target, propertyKey, attributes) {\n              if (!IsUndefined(propertyKey)) {\n                  if (!IsArray(decorators))\n                      throw new TypeError();\n                  if (!IsObject(target))\n                      throw new TypeError();\n                  if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))\n                      throw new TypeError();\n                  if (IsNull(attributes))\n                      attributes = undefined;\n                  propertyKey = ToPropertyKey(propertyKey);\n                  return DecorateProperty(decorators, target, propertyKey, attributes);\n              }\n              else {\n                  if (!IsArray(decorators))\n                      throw new TypeError();\n                  if (!IsConstructor(target))\n                      throw new TypeError();\n                  return DecorateConstructor(decorators, target);\n              }\n          }\n          exporter(\"decorate\", decorate);\n          // 4.1.2 Reflect.metadata(metadataKey, metadataValue)\n          // https://rbuckton.github.io/reflect-metadata/#reflect.metadata\n          /**\n           * A default metadata decorator factory that can be used on a class, class member, or parameter.\n           * @param metadataKey The key for the metadata entry.\n           * @param metadataValue The value for the metadata entry.\n           * @returns A decorator function.\n           * @remarks\n           * If `metadataKey` is already defined for the target and target key, the\n           * metadataValue for that key will be overwritten.\n           * @example\n           *\n           *     // constructor\n           *     @Reflect.metadata(key, value)\n           *     class Example {\n           *     }\n           *\n           *     // property (on constructor, TypeScript only)\n           *     class Example {\n           *         @Reflect.metadata(key, value)\n           *         static staticProperty;\n           *     }\n           *\n           *     // property (on prototype, TypeScript only)\n           *     class Example {\n           *         @Reflect.metadata(key, value)\n           *         property;\n           *     }\n           *\n           *     // method (on constructor)\n           *     class Example {\n           *         @Reflect.metadata(key, value)\n           *         static staticMethod() { }\n           *     }\n           *\n           *     // method (on prototype)\n           *     class Example {\n           *         @Reflect.metadata(key, value)\n           *         method() { }\n           *     }\n           *\n           */\n          function metadata(metadataKey, metadataValue) {\n              function decorator(target, propertyKey) {\n                  if (!IsObject(target))\n                      throw new TypeError();\n                  if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))\n                      throw new TypeError();\n                  OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n              }\n              return decorator;\n          }\n          exporter(\"metadata\", metadata);\n          /**\n           * Define a unique metadata entry on the target.\n           * @param metadataKey A key used to store and retrieve metadata.\n           * @param metadataValue A value that contains attached metadata.\n           * @param target The target object on which to define metadata.\n           * @param propertyKey (Optional) The property key for the target.\n           * @example\n           *\n           *     class Example {\n           *         // property declarations are not part of ES6, though they are valid in TypeScript:\n           *         // static staticProperty;\n           *         // property;\n           *\n           *         constructor(p) { }\n           *         static staticMethod(p) { }\n           *         method(p) { }\n           *     }\n           *\n           *     // constructor\n           *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\n           *\n           *     // property (on constructor)\n           *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\n           *\n           *     // property (on prototype)\n           *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\n           *\n           *     // method (on constructor)\n           *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\n           *\n           *     // method (on prototype)\n           *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\n           *\n           *     // decorator factory as metadata-producing annotation.\n           *     function MyAnnotation(options): Decorator {\n           *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n           *     }\n           *\n           */\n          function defineMetadata(metadataKey, metadataValue, target, propertyKey) {\n              if (!IsObject(target))\n                  throw new TypeError();\n              if (!IsUndefined(propertyKey))\n                  propertyKey = ToPropertyKey(propertyKey);\n              return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n          }\n          exporter(\"defineMetadata\", defineMetadata);\n          /**\n           * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n           * @param metadataKey A key used to store and retrieve metadata.\n           * @param target The target object on which the metadata is defined.\n           * @param propertyKey (Optional) The property key for the target.\n           * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n           * @example\n           *\n           *     class Example {\n           *         // property declarations are not part of ES6, though they are valid in TypeScript:\n           *         // static staticProperty;\n           *         // property;\n           *\n           *         constructor(p) { }\n           *         static staticMethod(p) { }\n           *         method(p) { }\n           *     }\n           *\n           *     // constructor\n           *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\n           *\n           *     // property (on constructor)\n           *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\n           *\n           *     // property (on prototype)\n           *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\n           *\n           *     // method (on constructor)\n           *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\n           *\n           *     // method (on prototype)\n           *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\n           *\n           */\n          function hasMetadata(metadataKey, target, propertyKey) {\n              if (!IsObject(target))\n                  throw new TypeError();\n              if (!IsUndefined(propertyKey))\n                  propertyKey = ToPropertyKey(propertyKey);\n              return OrdinaryHasMetadata(metadataKey, target, propertyKey);\n          }\n          exporter(\"hasMetadata\", hasMetadata);\n          /**\n           * Gets a value indicating whether the target object has the provided metadata key defined.\n           * @param metadataKey A key used to store and retrieve metadata.\n           * @param target The target object on which the metadata is defined.\n           * @param propertyKey (Optional) The property key for the target.\n           * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n           * @example\n           *\n           *     class Example {\n           *         // property declarations are not part of ES6, though they are valid in TypeScript:\n           *         // static staticProperty;\n           *         // property;\n           *\n           *         constructor(p) { }\n           *         static staticMethod(p) { }\n           *         method(p) { }\n           *     }\n           *\n           *     // constructor\n           *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\n           *\n           *     // property (on constructor)\n           *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n           *\n           *     // property (on prototype)\n           *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n           *\n           *     // method (on constructor)\n           *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n           *\n           *     // method (on prototype)\n           *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n           *\n           */\n          function hasOwnMetadata(metadataKey, target, propertyKey) {\n              if (!IsObject(target))\n                  throw new TypeError();\n              if (!IsUndefined(propertyKey))\n                  propertyKey = ToPropertyKey(propertyKey);\n              return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);\n          }\n          exporter(\"hasOwnMetadata\", hasOwnMetadata);\n          /**\n           * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n           * @param metadataKey A key used to store and retrieve metadata.\n           * @param target The target object on which the metadata is defined.\n           * @param propertyKey (Optional) The property key for the target.\n           * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n           * @example\n           *\n           *     class Example {\n           *         // property declarations are not part of ES6, though they are valid in TypeScript:\n           *         // static staticProperty;\n           *         // property;\n           *\n           *         constructor(p) { }\n           *         static staticMethod(p) { }\n           *         method(p) { }\n           *     }\n           *\n           *     // constructor\n           *     result = Reflect.getMetadata(\"custom:annotation\", Example);\n           *\n           *     // property (on constructor)\n           *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\n           *\n           *     // property (on prototype)\n           *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\n           *\n           *     // method (on constructor)\n           *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\n           *\n           *     // method (on prototype)\n           *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\n           *\n           */\n          function getMetadata(metadataKey, target, propertyKey) {\n              if (!IsObject(target))\n                  throw new TypeError();\n              if (!IsUndefined(propertyKey))\n                  propertyKey = ToPropertyKey(propertyKey);\n              return OrdinaryGetMetadata(metadataKey, target, propertyKey);\n          }\n          exporter(\"getMetadata\", getMetadata);\n          /**\n           * Gets the metadata value for the provided metadata key on the target object.\n           * @param metadataKey A key used to store and retrieve metadata.\n           * @param target The target object on which the metadata is defined.\n           * @param propertyKey (Optional) The property key for the target.\n           * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n           * @example\n           *\n           *     class Example {\n           *         // property declarations are not part of ES6, though they are valid in TypeScript:\n           *         // static staticProperty;\n           *         // property;\n           *\n           *         constructor(p) { }\n           *         static staticMethod(p) { }\n           *         method(p) { }\n           *     }\n           *\n           *     // constructor\n           *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\n           *\n           *     // property (on constructor)\n           *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n           *\n           *     // property (on prototype)\n           *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n           *\n           *     // method (on constructor)\n           *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n           *\n           *     // method (on prototype)\n           *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n           *\n           */\n          function getOwnMetadata(metadataKey, target, propertyKey) {\n              if (!IsObject(target))\n                  throw new TypeError();\n              if (!IsUndefined(propertyKey))\n                  propertyKey = ToPropertyKey(propertyKey);\n              return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);\n          }\n          exporter(\"getOwnMetadata\", getOwnMetadata);\n          /**\n           * Gets the metadata keys defined on the target object or its prototype chain.\n           * @param target The target object on which the metadata is defined.\n           * @param propertyKey (Optional) The property key for the target.\n           * @returns An array of unique metadata keys.\n           * @example\n           *\n           *     class Example {\n           *         // property declarations are not part of ES6, though they are valid in TypeScript:\n           *         // static staticProperty;\n           *         // property;\n           *\n           *         constructor(p) { }\n           *         static staticMethod(p) { }\n           *         method(p) { }\n           *     }\n           *\n           *     // constructor\n           *     result = Reflect.getMetadataKeys(Example);\n           *\n           *     // property (on constructor)\n           *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\n           *\n           *     // property (on prototype)\n           *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\n           *\n           *     // method (on constructor)\n           *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\n           *\n           *     // method (on prototype)\n           *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\n           *\n           */\n          function getMetadataKeys(target, propertyKey) {\n              if (!IsObject(target))\n                  throw new TypeError();\n              if (!IsUndefined(propertyKey))\n                  propertyKey = ToPropertyKey(propertyKey);\n              return OrdinaryMetadataKeys(target, propertyKey);\n          }\n          exporter(\"getMetadataKeys\", getMetadataKeys);\n          /**\n           * Gets the unique metadata keys defined on the target object.\n           * @param target The target object on which the metadata is defined.\n           * @param propertyKey (Optional) The property key for the target.\n           * @returns An array of unique metadata keys.\n           * @example\n           *\n           *     class Example {\n           *         // property declarations are not part of ES6, though they are valid in TypeScript:\n           *         // static staticProperty;\n           *         // property;\n           *\n           *         constructor(p) { }\n           *         static staticMethod(p) { }\n           *         method(p) { }\n           *     }\n           *\n           *     // constructor\n           *     result = Reflect.getOwnMetadataKeys(Example);\n           *\n           *     // property (on constructor)\n           *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\n           *\n           *     // property (on prototype)\n           *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\n           *\n           *     // method (on constructor)\n           *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\n           *\n           *     // method (on prototype)\n           *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\n           *\n           */\n          function getOwnMetadataKeys(target, propertyKey) {\n              if (!IsObject(target))\n                  throw new TypeError();\n              if (!IsUndefined(propertyKey))\n                  propertyKey = ToPropertyKey(propertyKey);\n              return OrdinaryOwnMetadataKeys(target, propertyKey);\n          }\n          exporter(\"getOwnMetadataKeys\", getOwnMetadataKeys);\n          /**\n           * Deletes the metadata entry from the target object with the provided key.\n           * @param metadataKey A key used to store and retrieve metadata.\n           * @param target The target object on which the metadata is defined.\n           * @param propertyKey (Optional) The property key for the target.\n           * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n           * @example\n           *\n           *     class Example {\n           *         // property declarations are not part of ES6, though they are valid in TypeScript:\n           *         // static staticProperty;\n           *         // property;\n           *\n           *         constructor(p) { }\n           *         static staticMethod(p) { }\n           *         method(p) { }\n           *     }\n           *\n           *     // constructor\n           *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\n           *\n           *     // property (on constructor)\n           *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\n           *\n           *     // property (on prototype)\n           *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\n           *\n           *     // method (on constructor)\n           *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\n           *\n           *     // method (on prototype)\n           *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\n           *\n           */\n          function deleteMetadata(metadataKey, target, propertyKey) {\n              if (!IsObject(target))\n                  throw new TypeError();\n              if (!IsUndefined(propertyKey))\n                  propertyKey = ToPropertyKey(propertyKey);\n              var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);\n              if (IsUndefined(metadataMap))\n                  return false;\n              if (!metadataMap.delete(metadataKey))\n                  return false;\n              if (metadataMap.size > 0)\n                  return true;\n              var targetMetadata = Metadata.get(target);\n              targetMetadata.delete(propertyKey);\n              if (targetMetadata.size > 0)\n                  return true;\n              Metadata.delete(target);\n              return true;\n          }\n          exporter(\"deleteMetadata\", deleteMetadata);\n          function DecorateConstructor(decorators, target) {\n              for (var i = decorators.length - 1; i >= 0; --i) {\n                  var decorator = decorators[i];\n                  var decorated = decorator(target);\n                  if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                      if (!IsConstructor(decorated))\n                          throw new TypeError();\n                      target = decorated;\n                  }\n              }\n              return target;\n          }\n          function DecorateProperty(decorators, target, propertyKey, descriptor) {\n              for (var i = decorators.length - 1; i >= 0; --i) {\n                  var decorator = decorators[i];\n                  var decorated = decorator(target, propertyKey, descriptor);\n                  if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                      if (!IsObject(decorated))\n                          throw new TypeError();\n                      descriptor = decorated;\n                  }\n              }\n              return descriptor;\n          }\n          function GetOrCreateMetadataMap(O, P, Create) {\n              var targetMetadata = Metadata.get(O);\n              if (IsUndefined(targetMetadata)) {\n                  if (!Create)\n                      return undefined;\n                  targetMetadata = new _Map();\n                  Metadata.set(O, targetMetadata);\n              }\n              var metadataMap = targetMetadata.get(P);\n              if (IsUndefined(metadataMap)) {\n                  if (!Create)\n                      return undefined;\n                  metadataMap = new _Map();\n                  targetMetadata.set(P, metadataMap);\n              }\n              return metadataMap;\n          }\n          // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\n          // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\n          function OrdinaryHasMetadata(MetadataKey, O, P) {\n              var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n              if (hasOwn)\n                  return true;\n              var parent = OrdinaryGetPrototypeOf(O);\n              if (!IsNull(parent))\n                  return OrdinaryHasMetadata(MetadataKey, parent, P);\n              return false;\n          }\n          // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n          // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\n          function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\n              var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n              if (IsUndefined(metadataMap))\n                  return false;\n              return ToBoolean(metadataMap.has(MetadataKey));\n          }\n          // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\n          // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\n          function OrdinaryGetMetadata(MetadataKey, O, P) {\n              var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n              if (hasOwn)\n                  return OrdinaryGetOwnMetadata(MetadataKey, O, P);\n              var parent = OrdinaryGetPrototypeOf(O);\n              if (!IsNull(parent))\n                  return OrdinaryGetMetadata(MetadataKey, parent, P);\n              return undefined;\n          }\n          // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n          // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\n          function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\n              var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n              if (IsUndefined(metadataMap))\n                  return undefined;\n              return metadataMap.get(MetadataKey);\n          }\n          // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n          // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\n          function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\n              var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);\n              metadataMap.set(MetadataKey, MetadataValue);\n          }\n          // 3.1.6.1 OrdinaryMetadataKeys(O, P)\n          // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\n          function OrdinaryMetadataKeys(O, P) {\n              var ownKeys = OrdinaryOwnMetadataKeys(O, P);\n              var parent = OrdinaryGetPrototypeOf(O);\n              if (parent === null)\n                  return ownKeys;\n              var parentKeys = OrdinaryMetadataKeys(parent, P);\n              if (parentKeys.length <= 0)\n                  return ownKeys;\n              if (ownKeys.length <= 0)\n                  return parentKeys;\n              var set = new _Set();\n              var keys = [];\n              for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {\n                  var key = ownKeys_1[_i];\n                  var hasKey = set.has(key);\n                  if (!hasKey) {\n                      set.add(key);\n                      keys.push(key);\n                  }\n              }\n              for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {\n                  var key = parentKeys_1[_a];\n                  var hasKey = set.has(key);\n                  if (!hasKey) {\n                      set.add(key);\n                      keys.push(key);\n                  }\n              }\n              return keys;\n          }\n          // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n          // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\n          function OrdinaryOwnMetadataKeys(O, P) {\n              var keys = [];\n              var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n              if (IsUndefined(metadataMap))\n                  return keys;\n              var keysObj = metadataMap.keys();\n              var iterator = GetIterator(keysObj);\n              var k = 0;\n              while (true) {\n                  var next = IteratorStep(iterator);\n                  if (!next) {\n                      keys.length = k;\n                      return keys;\n                  }\n                  var nextValue = IteratorValue(next);\n                  try {\n                      keys[k] = nextValue;\n                  }\n                  catch (e) {\n                      try {\n                          IteratorClose(iterator);\n                      }\n                      finally {\n                          throw e;\n                      }\n                  }\n                  k++;\n              }\n          }\n          // 6 ECMAScript Data Typ0es and Values\n          // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\n          function Type(x) {\n              if (x === null)\n                  return 1 /* Null */;\n              switch (typeof x) {\n                  case \"undefined\": return 0 /* Undefined */;\n                  case \"boolean\": return 2 /* Boolean */;\n                  case \"string\": return 3 /* String */;\n                  case \"symbol\": return 4 /* Symbol */;\n                  case \"number\": return 5 /* Number */;\n                  case \"object\": return x === null ? 1 /* Null */ : 6 /* Object */;\n                  default: return 6 /* Object */;\n              }\n          }\n          // 6.1.1 The Undefined Type\n          // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\n          function IsUndefined(x) {\n              return x === undefined;\n          }\n          // 6.1.2 The Null Type\n          // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\n          function IsNull(x) {\n              return x === null;\n          }\n          // 6.1.5 The Symbol Type\n          // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\n          function IsSymbol(x) {\n              return typeof x === \"symbol\";\n          }\n          // 6.1.7 The Object Type\n          // https://tc39.github.io/ecma262/#sec-object-type\n          function IsObject(x) {\n              return isObject(x) ? x !== null : isFunction(x);\n          }\n          // 7.1 Type Conversion\n          // https://tc39.github.io/ecma262/#sec-type-conversion\n          // 7.1.1 ToPrimitive(input [, PreferredType])\n          // https://tc39.github.io/ecma262/#sec-toprimitive\n          function ToPrimitive(input, PreferredType) {\n              switch (Type(input)) {\n                  case 0 /* Undefined */: return input;\n                  case 1 /* Null */: return input;\n                  case 2 /* Boolean */: return input;\n                  case 3 /* String */: return input;\n                  case 4 /* Symbol */: return input;\n                  case 5 /* Number */: return input;\n              }\n              var hint = PreferredType === 3 /* String */ ? \"string\" : PreferredType === 5 /* Number */ ? \"number\" : \"default\";\n              var exoticToPrim = GetMethod(input, toPrimitiveSymbol);\n              if (exoticToPrim !== undefined) {\n                  var result = exoticToPrim.call(input, hint);\n                  if (IsObject(result))\n                      throw new TypeError();\n                  return result;\n              }\n              return OrdinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\n          }\n          // 7.1.1.1 OrdinaryToPrimitive(O, hint)\n          // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\n          function OrdinaryToPrimitive(O, hint) {\n              if (hint === \"string\") {\n                  var toString_1 = O.toString;\n                  if (IsCallable(toString_1)) {\n                      var result = toString_1.call(O);\n                      if (!IsObject(result))\n                          return result;\n                  }\n                  var valueOf = O.valueOf;\n                  if (IsCallable(valueOf)) {\n                      var result = valueOf.call(O);\n                      if (!IsObject(result))\n                          return result;\n                  }\n              }\n              else {\n                  var valueOf = O.valueOf;\n                  if (IsCallable(valueOf)) {\n                      var result = valueOf.call(O);\n                      if (!IsObject(result))\n                          return result;\n                  }\n                  var toString_2 = O.toString;\n                  if (IsCallable(toString_2)) {\n                      var result = toString_2.call(O);\n                      if (!IsObject(result))\n                          return result;\n                  }\n              }\n              throw new TypeError();\n          }\n          // 7.1.2 ToBoolean(argument)\n          // https://tc39.github.io/ecma262/2016/#sec-toboolean\n          function ToBoolean(argument) {\n              return !!argument;\n          }\n          // 7.1.12 ToString(argument)\n          // https://tc39.github.io/ecma262/#sec-tostring\n          function ToString(argument) {\n              return \"\" + argument;\n          }\n          // 7.1.14 ToPropertyKey(argument)\n          // https://tc39.github.io/ecma262/#sec-topropertykey\n          function ToPropertyKey(argument) {\n              var key = ToPrimitive(argument, 3 /* String */);\n              if (IsSymbol(key))\n                  return key;\n              return ToString(key);\n          }\n          // 7.2 Testing and Comparison Operations\n          // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\n          // 7.2.2 IsArray(argument)\n          // https://tc39.github.io/ecma262/#sec-isarray\n          function IsArray(argument) {\n              return Array.isArray\n                  ? Array.isArray(argument)\n                  : argument instanceof Object\n                      ? argument instanceof Array\n                      : Object.prototype.toString.call(argument) === \"[object Array]\";\n          }\n          // 7.2.3 IsCallable(argument)\n          // https://tc39.github.io/ecma262/#sec-iscallable\n          function IsCallable(argument) {\n              // NOTE: This is an approximation as we cannot check for [[Call]] internal method.\n              return isFunction(argument);\n          }\n          // 7.2.4 IsConstructor(argument)\n          // https://tc39.github.io/ecma262/#sec-isconstructor\n          function IsConstructor(argument) {\n              // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\n              return isFunction(argument);\n          }\n          // 7.2.7 IsPropertyKey(argument)\n          // https://tc39.github.io/ecma262/#sec-ispropertykey\n          function IsPropertyKey(argument) {\n              switch (Type(argument)) {\n                  case 3 /* String */: return true;\n                  case 4 /* Symbol */: return true;\n                  default: return false;\n              }\n          }\n          // 7.3 Operations on Objects\n          // https://tc39.github.io/ecma262/#sec-operations-on-objects\n          // 7.3.9 GetMethod(V, P)\n          // https://tc39.github.io/ecma262/#sec-getmethod\n          function GetMethod(V, P) {\n              var func = V[P];\n              if (func === undefined || func === null)\n                  return undefined;\n              if (!IsCallable(func))\n                  throw new TypeError();\n              return func;\n          }\n          // 7.4 Operations on Iterator Objects\n          // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\n          function GetIterator(obj) {\n              var method = GetMethod(obj, iteratorSymbol);\n              if (!IsCallable(method))\n                  throw new TypeError(); // from Call\n              var iterator = method.call(obj);\n              if (!IsObject(iterator))\n                  throw new TypeError();\n              return iterator;\n          }\n          // 7.4.4 IteratorValue(iterResult)\n          // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\n          function IteratorValue(iterResult) {\n              return iterResult.value;\n          }\n          // 7.4.5 IteratorStep(iterator)\n          // https://tc39.github.io/ecma262/#sec-iteratorstep\n          function IteratorStep(iterator) {\n              var result = iterator.next();\n              return result.done ? false : result;\n          }\n          // 7.4.6 IteratorClose(iterator, completion)\n          // https://tc39.github.io/ecma262/#sec-iteratorclose\n          function IteratorClose(iterator) {\n              var f = iterator[\"return\"];\n              if (f)\n                  f.call(iterator);\n          }\n          // 9.1 Ordinary Object Internal Methods and Internal Slots\n          // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\n          // 9.1.1.1 OrdinaryGetPrototypeOf(O)\n          // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\n          function OrdinaryGetPrototypeOf(O) {\n              var proto = Object.getPrototypeOf(O);\n              if (!isFunction(O) || O === functionPrototype)\n                  return proto;\n              // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\n              // Try to determine the superclass constructor. Compatible implementations\n              // must either set __proto__ on a subclass constructor to the superclass constructor,\n              // or ensure each class has a valid `constructor` property on its prototype that\n              // points back to the constructor.\n              // If this is not the same as Function.[[Prototype]], then this is definately inherited.\n              // This is the case when in ES6 or when using __proto__ in a compatible browser.\n              if (proto !== functionPrototype)\n                  return proto;\n              // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\n              var prototype = O.prototype;\n              var prototypeProto = prototype && Object.getPrototypeOf(prototype);\n              if (prototypeProto == null || prototypeProto === Object.prototype)\n                  return proto;\n              // If the constructor was not a function, then we cannot determine the heritage.\n              var constructor = prototypeProto.constructor;\n              if (!isFunction(constructor))\n                  return proto;\n              // If we have some kind of self-reference, then we cannot determine the heritage.\n              if (constructor === O)\n                  return proto;\n              // we have a pretty good guess at the heritage.\n              return constructor;\n          }\n          // naive Map shim\n          // function CreateMapPolyfill() {\n          //     var cacheSentinel = {};\n          //     var arraySentinel = [];\n          //     var MapIterator = /** @class */ (function () {\n          //         function MapIterator(keys, values, selector) {\n          //             this._index = 0;\n          //             this._keys = keys;\n          //             this._values = values;\n          //             this._selector = selector;\n          //         }\n          //         MapIterator.prototype[\"@@iterator\"] = function () { return this; };\n          //         MapIterator.prototype[iteratorSymbol] = function () { return this; };\n          //         MapIterator.prototype.next = function () {\n          //             var index = this._index;\n          //             if (index >= 0 && index < this._keys.length) {\n          //                 var result = this._selector(this._keys[index], this._values[index]);\n          //                 if (index + 1 >= this._keys.length) {\n          //                     this._index = -1;\n          //                     this._keys = arraySentinel;\n          //                     this._values = arraySentinel;\n          //                 }\n          //                 else {\n          //                     this._index++;\n          //                 }\n          //                 return { value: result, done: false };\n          //             }\n          //             return { value: undefined, done: true };\n          //         };\n          //         MapIterator.prototype.throw = function (error) {\n          //             if (this._index >= 0) {\n          //                 this._index = -1;\n          //                 this._keys = arraySentinel;\n          //                 this._values = arraySentinel;\n          //             }\n          //             throw error;\n          //         };\n          //         MapIterator.prototype.return = function (value) {\n          //             if (this._index >= 0) {\n          //                 this._index = -1;\n          //                 this._keys = arraySentinel;\n          //                 this._values = arraySentinel;\n          //             }\n          //             return { value: value, done: true };\n          //         };\n          //         return MapIterator;\n          //     }());\n          //     return /** @class */ (function () {\n          //         function Map() {\n          //             this._keys = [];\n          //             this._values = [];\n          //             this._cacheKey = cacheSentinel;\n          //             this._cacheIndex = -2;\n          //         }\n          //         Object.defineProperty(Map.prototype, \"size\", {\n          //             get: function () { return this._keys.length; },\n          //             enumerable: true,\n          //             configurable: true\n          //         });\n          //         Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };\n          //         Map.prototype.get = function (key) {\n          //             var index = this._find(key, /*insert*/ false);\n          //             return index >= 0 ? this._values[index] : undefined;\n          //         };\n          //         Map.prototype.set = function (key, value) {\n          //             var index = this._find(key, /*insert*/ true);\n          //             this._values[index] = value;\n          //             return this;\n          //         };\n          //         Map.prototype.delete = function (key) {\n          //             var index = this._find(key, /*insert*/ false);\n          //             if (index >= 0) {\n          //                 var size = this._keys.length;\n          //                 for (var i = index + 1; i < size; i++) {\n          //                     this._keys[i - 1] = this._keys[i];\n          //                     this._values[i - 1] = this._values[i];\n          //                 }\n          //                 this._keys.length--;\n          //                 this._values.length--;\n          //                 if (key === this._cacheKey) {\n          //                     this._cacheKey = cacheSentinel;\n          //                     this._cacheIndex = -2;\n          //                 }\n          //                 return true;\n          //             }\n          //             return false;\n          //         };\n          //         Map.prototype.clear = function () {\n          //             this._keys.length = 0;\n          //             this._values.length = 0;\n          //             this._cacheKey = cacheSentinel;\n          //             this._cacheIndex = -2;\n          //         };\n          //         Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };\n          //         Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };\n          //         Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };\n          //         Map.prototype[\"@@iterator\"] = function () { return this.entries(); };\n          //         Map.prototype[iteratorSymbol] = function () { return this.entries(); };\n          //         Map.prototype._find = function (key, insert) {\n          //             if (this._cacheKey !== key) {\n          //                 this._cacheIndex = this._keys.indexOf(this._cacheKey = key);\n          //             }\n          //             if (this._cacheIndex < 0 && insert) {\n          //                 this._cacheIndex = this._keys.length;\n          //                 this._keys.push(key);\n          //                 this._values.push(undefined);\n          //             }\n          //             return this._cacheIndex;\n          //         };\n          //         return Map;\n          //     }());\n          //     function getKey(key, _) {\n          //         return key;\n          //     }\n          //     function getValue(_, value) {\n          //         return value;\n          //     }\n          //     function getEntry(key, value) {\n          //         return [key, value];\n          //     }\n          // }\n          // naive Set shim\n          // function CreateSetPolyfill() {\n          //     return /** @class */ (function () {\n          //         function Set() {\n          //             this._map = new _Map();\n          //         }\n          //         Object.defineProperty(Set.prototype, \"size\", {\n          //             get: function () { return this._map.size; },\n          //             enumerable: true,\n          //             configurable: true\n          //         });\n          //         Set.prototype.has = function (value) { return this._map.has(value); };\n          //         Set.prototype.add = function (value) { return this._map.set(value, value), this; };\n          //         Set.prototype.delete = function (value) { return this._map.delete(value); };\n          //         Set.prototype.clear = function () { this._map.clear(); };\n          //         Set.prototype.keys = function () { return this._map.keys(); };\n          //         Set.prototype.values = function () { return this._map.values(); };\n          //         Set.prototype.entries = function () { return this._map.entries(); };\n          //         Set.prototype[\"@@iterator\"] = function () { return this.keys(); };\n          //         Set.prototype[iteratorSymbol] = function () { return this.keys(); };\n          //         return Set;\n          //     }());\n          // }\n          // naive WeakMap shim\n          function CreateWeakMapPolyfill() {\n              var UUID_SIZE = 16;\n              var keys = HashMap.create();\n              var rootKey = CreateUniqueKey();\n              return /** @class */ (function () {\n                  function WeakMap() {\n                      this._key = CreateUniqueKey();\n                  }\n                  WeakMap.prototype.has = function (target) {\n                      var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                      return table !== undefined ? HashMap.has(table, this._key) : false;\n                  };\n                  WeakMap.prototype.get = function (target) {\n                      var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                      return table !== undefined ? HashMap.get(table, this._key) : undefined;\n                  };\n                  WeakMap.prototype.set = function (target, value) {\n                      var table = GetOrCreateWeakMapTable(target, /*create*/ true);\n                      table[this._key] = value;\n                      return this;\n                  };\n                  WeakMap.prototype.delete = function (target) {\n                      var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                      return table !== undefined ? delete table[this._key] : false;\n                  };\n                  WeakMap.prototype.clear = function () {\n                      // NOTE: not a real clear, just makes the previous data unreachable\n                      this._key = CreateUniqueKey();\n                  };\n                  return WeakMap;\n              }());\n              function CreateUniqueKey() {\n                  var key;\n                  do\n                      key = \"@@WeakMap@@\" + CreateUUID();\n                  while (HashMap.has(keys, key));\n                  keys[key] = true;\n                  return key;\n              }\n              function GetOrCreateWeakMapTable(target, create) {\n                  if (!hasOwn.call(target, rootKey)) {\n                      if (!create)\n                          return undefined;\n                      Object.defineProperty(target, rootKey, { value: HashMap.create() });\n                  }\n                  return target[rootKey];\n              }\n              function FillRandomBytes(buffer, size) {\n                  for (var i = 0; i < size; ++i)\n                      buffer[i] = Math.random() * 0xff | 0;\n                  return buffer;\n              }\n              function GenRandomBytes(size) {\n                  if (isFunction(Uint8Array)) {\n                      if (!isUndefined(crypto))\n                          return crypto.getRandomValues(new Uint8Array(size));\n                      if (!isUndefined(msCrypto))\n                          return msCrypto.getRandomValues(new Uint8Array(size));\n                      return FillRandomBytes(new Uint8Array(size), size);\n                  }\n                  return FillRandomBytes(new Array(size), size);\n              }\n              function CreateUUID() {\n                  var data = GenRandomBytes(UUID_SIZE);\n                  // mark as random - RFC 4122 § 4.4\n                  data[6] = data[6] & 0x4f | 0x40;\n                  data[8] = data[8] & 0xbf | 0x80;\n                  var result = \"\";\n                  for (var offset = 0; offset < UUID_SIZE; ++offset) {\n                      var byte = data[offset];\n                      if (offset === 4 || offset === 6 || offset === 8)\n                          result += \"-\";\n                      if (byte < 16)\n                          result += \"0\";\n                      result += byte.toString(16).toLowerCase();\n                  }\n                  return result;\n              }\n          }\n          // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\n          function MakeDictionary(obj) {\n              obj.__ = undefined;\n              delete obj.__;\n              return obj;\n          }\n      });\n  })(Reflect || (Reflect = {}));\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\n\nconst PROPERTY_THRESHOLD = 2046;\r\nconst SET_DATA = '小程序 setData';\r\nconst PAGE_INIT = '页面初始化';\r\nconst ROOT_STR = 'root';\r\nconst HTML = 'html';\r\nconst HEAD = 'head';\r\nconst BODY = 'body';\r\nconst APP = 'app';\r\nconst CONTAINER = 'container';\r\nconst DOCUMENT_ELEMENT_NAME = '#document';\r\nconst DOCUMENT_FRAGMENT = 'document-fragment';\r\nconst ID = 'id';\r\nconst UID = 'uid';\r\nconst CLASS = 'class';\r\nconst STYLE = 'style';\r\nconst FOCUS = 'focus';\r\nconst VIEW = 'view';\r\nconst STATIC_VIEW = 'static-view';\r\nconst PURE_VIEW = 'pure-view';\r\nconst PROPS = 'props';\r\nconst DATASET = 'dataset';\r\nconst OBJECT = 'object';\r\nconst VALUE = 'value';\r\nconst INPUT = 'input';\r\nconst CHANGE = 'change';\r\nconst CUSTOM_WRAPPER = 'custom-wrapper';\r\nconst TARGET = 'target';\r\nconst CURRENT_TARGET = 'currentTarget';\r\nconst TYPE = 'type';\r\nconst CONFIRM = 'confirm';\r\nconst TIME_STAMP = 'timeStamp';\r\nconst KEY_CODE = 'keyCode';\r\nconst TOUCHMOVE = 'touchmove';\r\nconst DATE = 'Date';\r\nconst CATCHMOVE = 'catchMove';\r\nconst CATCH_VIEW = 'catch-view';\r\nconst COMMENT = 'comment';\r\nconst ON_LOAD = 'onLoad';\r\nconst ON_READY = 'onReady';\r\nconst ON_SHOW = 'onShow';\r\nconst ON_HIDE = 'onHide';\r\nconst OPTIONS = 'options';\r\nconst EXTERNAL_CLASSES = 'externalClasses';\r\nconst BEHAVIORS = 'behaviors';\n\nconst incrementId = () => {\r\n    let id = 0;\r\n    return () => (id++).toString();\r\n};\r\nfunction isElement(node) {\r\n    return node.nodeType === 1 /* ELEMENT_NODE */;\r\n}\r\nfunction isText(node) {\r\n    return node.nodeType === 3 /* TEXT_NODE */;\r\n}\r\nfunction isComment(node) {\r\n    return node.nodeName === COMMENT;\r\n}\r\nfunction isHasExtractProp(el) {\r\n    const res = Object.keys(el.props).find(prop => {\r\n        return !(/^(class|style|id)$/.test(prop) || prop.startsWith('data-'));\r\n    });\r\n    return Boolean(res);\r\n}\r\n/**\r\n * 往上寻找组件树直到 root，寻找是否有祖先组件绑定了同类型的事件\r\n * @param node 当前组件\r\n * @param type 事件类型\r\n */\r\nfunction isParentBinded(node, type) {\r\n    var _a;\r\n    let res = false;\r\n    while ((node === null || node === void 0 ? void 0 : node.parentElement) && node.parentElement._path !== ROOT_STR) {\r\n        if ((_a = node.parentElement.__handlers[type]) === null || _a === void 0 ? void 0 : _a.length) {\r\n            res = true;\r\n            break;\r\n        }\r\n        node = node.parentElement;\r\n    }\r\n    return res;\r\n}\r\nfunction shortcutAttr(key) {\r\n    switch (key) {\r\n        case STYLE:\r\n            return \"st\" /* Style */;\r\n        case ID:\r\n            return UID;\r\n        case CLASS:\r\n            return \"cl\" /* Class */;\r\n        default:\r\n            return key;\r\n    }\r\n}\r\nconst customWrapperCache = new Map();\n\nconst SID_TARO_ELEMENT = '0';\r\nconst SID_TARO_ELEMENT_FACTORY = '1';\r\nconst SID_TARO_TEXT = '2';\r\nconst SID_TARO_TEXT_FACTORY = '3';\r\nconst SID_TARO_NODE_IMPL = '4';\r\nconst SID_TARO_ELEMENT_IMPL = '5';\r\nconst SID_HOOKS = '6';\r\nconst SID_ON_REMOVE_ATTRIBUTE = '7';\r\nconst SID_GET_MINI_LIFECYCLE = '8';\r\nconst SID_GET_LIFECYCLE = '9';\r\nconst SID_GET_PATH_INDEX = '10';\r\nconst SID_GET_EVENT_CENTER = '11';\r\nconst SID_IS_BUBBLE_EVENTS = '12';\r\nconst SID_GET_SPECIAL_NODES = '13';\r\nconst SID_EVENT_CENTER = '14';\r\nconst SID_MODIFY_MP_EVENT = '15';\r\nconst SID_MODIFY_TARO_EVENT = '16';\r\nconst SID_MODIFY_DISPATCH_EVENT = '17';\r\nconst SID_BATCHED_EVENT_UPDATES = '18';\r\nconst SID_MERGE_PAGE_INSTANCE = '19';\r\nconst SID_CREATE_PULLDOWN_COMPONENT = '20';\r\nconst SID_GET_DOM_NODE = '21';\r\nconst SID_INIT_NATIVE_API = '22';\r\nconst SID_MODIFY_HYDRATE_DATA = '23';\r\nconst SID_MODIFY_SET_ATTR_PAYLOAD = '24';\r\nconst SID_MODIFY_RM_ATTR_PAYLOAD = '25';\r\nconst SID_ON_ADD_EVENT = '26';\r\nconst SID_PATCH_ELEMENT = '27';\r\nconst SID_MODIFY_PAGE_OBJECT = '28';\r\nconst SERVICE_IDENTIFIER = {\r\n    TaroElement: SID_TARO_ELEMENT,\r\n    TaroElementFactory: SID_TARO_ELEMENT_FACTORY,\r\n    TaroText: SID_TARO_TEXT,\r\n    TaroTextFactory: SID_TARO_TEXT_FACTORY,\r\n    TaroNodeImpl: SID_TARO_NODE_IMPL,\r\n    TaroElementImpl: SID_TARO_ELEMENT_IMPL,\r\n    Hooks: SID_HOOKS,\r\n    onRemoveAttribute: SID_ON_REMOVE_ATTRIBUTE,\r\n    getMiniLifecycle: SID_GET_MINI_LIFECYCLE,\r\n    getLifecycle: SID_GET_LIFECYCLE,\r\n    getPathIndex: SID_GET_PATH_INDEX,\r\n    getEventCenter: SID_GET_EVENT_CENTER,\r\n    isBubbleEvents: SID_IS_BUBBLE_EVENTS,\r\n    getSpecialNodes: SID_GET_SPECIAL_NODES,\r\n    eventCenter: SID_EVENT_CENTER,\r\n    modifyMpEvent: SID_MODIFY_MP_EVENT,\r\n    modifyTaroEvent: SID_MODIFY_TARO_EVENT,\r\n    modifyDispatchEvent: SID_MODIFY_DISPATCH_EVENT,\r\n    batchedEventUpdates: SID_BATCHED_EVENT_UPDATES,\r\n    mergePageInstance: SID_MERGE_PAGE_INSTANCE,\r\n    createPullDownComponent: SID_CREATE_PULLDOWN_COMPONENT,\r\n    getDOMNode: SID_GET_DOM_NODE,\r\n    initNativeApi: SID_INIT_NATIVE_API,\r\n    modifyHydrateData: SID_MODIFY_HYDRATE_DATA,\r\n    modifySetAttrPayload: SID_MODIFY_SET_ATTR_PAYLOAD,\r\n    modifyRmAttrPayload: SID_MODIFY_RM_ATTR_PAYLOAD,\r\n    onAddEvent: SID_ON_ADD_EVENT,\r\n    patchElement: SID_PATCH_ELEMENT,\r\n    modifyPageObject: SID_MODIFY_PAGE_OBJECT\r\n};\n\nvar ElementNames;\r\n(function (ElementNames) {\r\n    ElementNames[\"Element\"] = \"Element\";\r\n    ElementNames[\"Document\"] = \"Document\";\r\n    ElementNames[\"RootElement\"] = \"RootElement\";\r\n    ElementNames[\"FormElement\"] = \"FormElement\";\r\n})(ElementNames || (ElementNames = {}));\n\nconst store = {\r\n    container: null\r\n};\r\nfunction getHooks() {\r\n    return store.container.get(SID_HOOKS);\r\n}\r\nfunction getElementFactory() {\r\n    return store.container.get(SID_TARO_ELEMENT_FACTORY);\r\n}\r\nfunction getNodeImpl() {\r\n    return store.container.get(SID_TARO_NODE_IMPL);\r\n}\r\nfunction getElementImpl() {\r\n    return store.container.get(SID_TARO_ELEMENT_IMPL);\r\n}\r\nfunction getDocument() {\r\n    const getElement = getElementFactory();\r\n    return getElement(ElementNames.Document)();\r\n}\n\nlet TaroEventTarget = class TaroEventTarget {\r\n    constructor() {\r\n        this.__handlers = {};\r\n        this.hooks = getHooks();\r\n    }\r\n    addEventListener(type, handler, options) {\r\n        var _a, _b;\r\n        type = type.toLowerCase();\r\n        (_b = (_a = this.hooks).onAddEvent) === null || _b === void 0 ? void 0 : _b.call(_a, type, handler, options, this);\r\n        if (type === 'regionchange') {\r\n            // map 组件的 regionchange 事件非常特殊，详情：https://github.com/NervJS/taro/issues/5766\r\n            this.addEventListener('begin', handler, options);\r\n            this.addEventListener('end', handler, options);\r\n            return;\r\n        }\r\n        let isCapture = Boolean(options);\r\n        let isOnce = false;\r\n        if (isObject(options)) {\r\n            isCapture = Boolean(options.capture);\r\n            isOnce = Boolean(options.once);\r\n        }\r\n        if (isOnce) {\r\n            const wrapper = function () {\r\n                handler.apply(this, arguments); // this 指向 Element\r\n                this.removeEventListener(type, wrapper);\r\n            };\r\n            this.addEventListener(type, wrapper, Object.assign(Object.assign({}, options), { once: false }));\r\n            return;\r\n        }\r\n        process.env.NODE_ENV !== 'production' && warn(isCapture, 'Taro 暂未实现 event 的 capture 特性。');\r\n        // 某些框架，如 PReact 有委托的机制，handler 始终是同一个函数\r\n        // 这会导致多层停止冒泡失败：view -> view(handler.stop = false) -> view(handler.stop = true)\r\n        // 这样解决：view -> view(handlerA.stop = false) -> view(handlerB.stop = false)\r\n        // 因此每次绑定事件都新建一个函数，如果带来了性能问题，可以把这段逻辑抽取到 PReact 插件中。\r\n        const oldHandler = handler;\r\n        handler = function () {\r\n            oldHandler.apply(this, arguments); // this 指向 Element\r\n        };\r\n        handler.oldHandler = oldHandler;\r\n        const handlers = this.__handlers[type];\r\n        if (isArray(handlers)) {\r\n            handlers.push(handler);\r\n        }\r\n        else {\r\n            this.__handlers[type] = [handler];\r\n        }\r\n    }\r\n    removeEventListener(type, handler) {\r\n        type = type.toLowerCase();\r\n        if (!handler) {\r\n            return;\r\n        }\r\n        const handlers = this.__handlers[type];\r\n        if (!isArray(handlers)) {\r\n            return;\r\n        }\r\n        const index = handlers.findIndex(item => {\r\n            if (item === handler || item.oldHandler === handler)\r\n                return true;\r\n        });\r\n        process.env.NODE_ENV !== 'production' && warn(index === -1, `事件: '${type}' 没有注册在 DOM 中，因此不会被移除。`);\r\n        handlers.splice(index, 1);\r\n    }\r\n    isAnyEventBinded() {\r\n        const handlers = this.__handlers;\r\n        const isAnyEventBinded = Object.keys(handlers).find(key => handlers[key].length);\r\n        return Boolean(isAnyEventBinded);\r\n    }\r\n};\r\nTaroEventTarget = __decorate([\r\n    injectable(),\r\n    __metadata(\"design:paramtypes\", [])\r\n], TaroEventTarget);\n\n/**\r\n * React also has a fancy function's name for this: `hydrate()`.\r\n * You may have been heard `hydrate` as a SSR-related function,\r\n * actually, `hydrate` basicly do the `render()` thing, but ignore some properties,\r\n * it's a vnode traverser and modifier: that's exactly what Taro's doing in here.\r\n */\r\nfunction hydrate(node) {\r\n    var _a, _b;\r\n    const nodeName = node.nodeName;\r\n    if (isText(node)) {\r\n        return {\r\n            [\"v\" /* Text */]: node.nodeValue,\r\n            [\"nn\" /* NodeName */]: nodeName\r\n        };\r\n    }\r\n    const data = {\r\n        [\"nn\" /* NodeName */]: nodeName,\r\n        sid: node.sid\r\n    };\r\n    const { props } = node;\r\n    const SPECIAL_NODES = node.hooks.getSpecialNodes();\r\n    if (node.uid !== node.sid) {\r\n        data.uid = node.uid;\r\n    }\r\n    if (!node.isAnyEventBinded() && SPECIAL_NODES.indexOf(nodeName) > -1) {\r\n        data[\"nn\" /* NodeName */] = `static-${nodeName}`;\r\n        if (nodeName === VIEW && !isHasExtractProp(node)) {\r\n            data[\"nn\" /* NodeName */] = PURE_VIEW;\r\n        }\r\n    }\r\n    for (const prop in props) {\r\n        const propInCamelCase = toCamelCase(prop);\r\n        if (!prop.startsWith('data-') && // 在 node.dataset 的数据\r\n            prop !== CLASS &&\r\n            prop !== STYLE &&\r\n            prop !== ID &&\r\n            propInCamelCase !== CATCHMOVE) {\r\n            data[propInCamelCase] = props[prop];\r\n        }\r\n        if (nodeName === VIEW && propInCamelCase === CATCHMOVE && props[prop] !== false) {\r\n            data[\"nn\" /* NodeName */] = CATCH_VIEW;\r\n        }\r\n    }\r\n    let { childNodes } = node;\r\n    // 过滤 comment 节点\r\n    childNodes = childNodes.filter(node => !isComment(node));\r\n    if (childNodes.length > 0) {\r\n        data[\"cn\" /* Childnodes */] = childNodes.map(hydrate);\r\n    }\r\n    else {\r\n        data[\"cn\" /* Childnodes */] = [];\r\n    }\r\n    if (node.className !== '') {\r\n        data[\"cl\" /* Class */] = node.className;\r\n    }\r\n    if (node.cssText !== '' && nodeName !== 'swiper-item') {\r\n        data[\"st\" /* Style */] = node.cssText;\r\n    }\r\n    (_b = (_a = node.hooks).modifyHydrateData) === null || _b === void 0 ? void 0 : _b.call(_a, data);\r\n    return data;\r\n}\n\nclass EventSource extends Map {\r\n    removeNode(child) {\r\n        const { sid, uid } = child;\r\n        this.delete(sid);\r\n        if (uid !== sid && uid)\r\n            this.delete(uid);\r\n    }\r\n    removeNodeTree(child) {\r\n        this.removeNode(child);\r\n        const { childNodes } = child;\r\n        childNodes.forEach(node => this.removeNodeTree(node));\r\n    }\r\n}\r\nconst eventSource = new EventSource();\n\nconst observers = [];\r\n/**\r\n * The MutationObserver provides the ability\r\n * to watch for changes being made to the DOM tree.\r\n * It will invoke a specified callback function\r\n * when DOM changes occur.\r\n * @see https://dom.spec.whatwg.org/#mutationobserver\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\r\n */\r\nclass MutationObserverImpl {\r\n    constructor(callback) {\r\n        this.records = [];\r\n        this.callback = callback;\r\n    }\r\n    /**\r\n     * Configures the MutationObserver\r\n     * to begin receiving notifications\r\n     * through its callback function\r\n     * when DOM changes matching the given options occur.\r\n     *\r\n     * Options matching is to be implemented.\r\n     */\r\n    observe(target, options) {\r\n        this.disconnect();\r\n        this.target = target;\r\n        this.options = options || {};\r\n        observers.push(this);\r\n    }\r\n    /**\r\n     * Stop the MutationObserver instance\r\n     * from receiving further notifications\r\n     * until and unless observe() is called again.\r\n     */\r\n    disconnect() {\r\n        this.target = null;\r\n        const index = observers.indexOf(this);\r\n        if (index >= 0) {\r\n            observers.splice(index, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Removes all pending notifications\r\n     * from the MutationObserver's notification queue\r\n     * and returns them in a new Array of MutationRecord objects.\r\n     */\r\n    takeRecords() {\r\n        return this.records.splice(0, this.records.length);\r\n    }\r\n}\r\n/** Match two TaroNodes by sid. */\r\nconst sidMatches = (observerTarget, target) => {\r\n    return !!observerTarget && observerTarget.sid === (target === null || target === void 0 ? void 0 : target.sid);\r\n};\r\nconst isConcerned = (record, options) => {\r\n    const { characterData, characterDataOldValue, attributes, attributeOldValue, childList } = options;\r\n    switch (record.type) {\r\n        case \"characterData\" /* CHARACTER_DATA */:\r\n            if (characterData) {\r\n                if (!characterDataOldValue)\r\n                    record.oldValue = null;\r\n                return true;\r\n            }\r\n            return false;\r\n        case \"attributes\" /* ATTRIBUTES */:\r\n            if (attributes) {\r\n                if (!attributeOldValue)\r\n                    record.oldValue = null;\r\n                return true;\r\n            }\r\n            return false;\r\n        case \"childList\" /* CHILD_LIST */:\r\n            if (childList) {\r\n                return true;\r\n            }\r\n            return false;\r\n    }\r\n};\r\nlet pendingMuatations = false;\r\nfunction logMutation(observer, record) {\r\n    observer.records.push(record);\r\n    if (!pendingMuatations) {\r\n        pendingMuatations = true;\r\n        Promise\r\n            .resolve()\r\n            .then(() => {\r\n            pendingMuatations = false;\r\n            observers.forEach(observer => {\r\n                return observer.callback(observer.takeRecords());\r\n            });\r\n        });\r\n    }\r\n}\r\nfunction recordMutation(record) {\r\n    observers.forEach(observer => {\r\n        const { options } = observer;\r\n        for (let t = record.target; t; t = t.parentNode) {\r\n            if (sidMatches(observer.target, t) && isConcerned(record, options)) {\r\n                logMutation(observer, record);\r\n                break;\r\n            }\r\n            if (!options.subtree)\r\n                break;\r\n        }\r\n    });\r\n}\n\nclass MutationObserver {\r\n    constructor(callback) {\r\n        if (ENABLE_MUTATION_OBSERVER) {\r\n            this.core = new MutationObserverImpl(callback);\r\n        }\r\n        else {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                console.warn('[Taro Warning] 若要使用 MutationObserver，请在 Taro 编译配置中设置 \\'mini.enableMutationObserver: true\\'');\r\n            }\r\n            this.core = {\r\n                observe: noop,\r\n                disconnect: noop,\r\n                takeRecords: noop\r\n            };\r\n        }\r\n    }\r\n    observe(...args) {\r\n        this.core.observe(...args);\r\n    }\r\n    disconnect() {\r\n        this.core.disconnect();\r\n    }\r\n    takeRecords() {\r\n        return this.core.takeRecords();\r\n    }\r\n    static record(record) {\r\n        recordMutation(record);\r\n    }\r\n}\n\nconst CHILDNODES = \"cn\" /* Childnodes */;\r\nconst nodeId = incrementId();\r\nlet TaroNode = class TaroNode extends TaroEventTarget {\r\n    constructor() {\r\n        super();\r\n        this.parentNode = null;\r\n        this.childNodes = [];\r\n        this._getElement = getElementFactory();\r\n        this.hydrate = (node) => () => hydrate(node);\r\n        const impl = getNodeImpl();\r\n        impl.bind(this);\r\n        this.uid = `_n_${nodeId()}`; // dom 节点 id，开发者可修改\r\n        this.sid = this.uid; // dom 节点全局唯一 id，不可被修改\r\n        eventSource.set(this.sid, this);\r\n    }\r\n    /**\r\n     * like jQuery's $.empty()\r\n     */\r\n    _empty() {\r\n        while (this.firstChild) {\r\n            // Data Structure\r\n            const child = this.firstChild;\r\n            child.parentNode = null;\r\n            this.childNodes.shift();\r\n            // eventSource\r\n            eventSource.removeNodeTree(child);\r\n        }\r\n    }\r\n    updateChildNodes(isClean) {\r\n        const cleanChildNodes = () => [];\r\n        const rerenderChildNodes = () => {\r\n            const childNodes = this.childNodes.filter(node => !isComment(node));\r\n            return childNodes.map(hydrate);\r\n        };\r\n        this.enqueueUpdate({\r\n            path: `${this._path}.${CHILDNODES}`,\r\n            value: isClean ? cleanChildNodes : rerenderChildNodes\r\n        });\r\n    }\r\n    get _root() {\r\n        var _a;\r\n        return ((_a = this.parentNode) === null || _a === void 0 ? void 0 : _a._root) || null;\r\n    }\r\n    findIndex(refChild) {\r\n        const index = this.childNodes.indexOf(refChild);\r\n        ensure(index !== -1, 'The node to be replaced is not a child of this node.');\r\n        return index;\r\n    }\r\n    get _path() {\r\n        const parentNode = this.parentNode;\r\n        if (parentNode) {\r\n            // 计算路径时，先过滤掉 comment 节点\r\n            const list = parentNode.childNodes.filter(node => !isComment(node));\r\n            const indexOfNode = list.indexOf(this);\r\n            const index = this.hooks.getPathIndex(indexOfNode);\r\n            return `${parentNode._path}.${CHILDNODES}.${index}`;\r\n        }\r\n        return '';\r\n    }\r\n    get nextSibling() {\r\n        const parentNode = this.parentNode;\r\n        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) + 1]) || null;\r\n    }\r\n    get previousSibling() {\r\n        const parentNode = this.parentNode;\r\n        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) - 1]) || null;\r\n    }\r\n    get parentElement() {\r\n        const parentNode = this.parentNode;\r\n        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 1 /* ELEMENT_NODE */) {\r\n            return parentNode;\r\n        }\r\n        return null;\r\n    }\r\n    get firstChild() {\r\n        return this.childNodes[0] || null;\r\n    }\r\n    get lastChild() {\r\n        const childNodes = this.childNodes;\r\n        return childNodes[childNodes.length - 1] || null;\r\n    }\r\n    /**\r\n     * @textContent 目前只能置空子元素\r\n     * @TODO 等待完整 innerHTML 实现\r\n     */\r\n    set textContent(text) {\r\n        const document = this._getElement(ElementNames.Document)();\r\n        const newText = document.createTextNode(text);\r\n        // @Todo: appendChild 会多触发一次\r\n        MutationObserver.record({\r\n            type: \"childList\" /* CHILD_LIST */,\r\n            target: this,\r\n            removedNodes: this.childNodes.slice(),\r\n            addedNodes: text === '' ? [] : [newText]\r\n        });\r\n        this._empty();\r\n        if (text === '') {\r\n            this.updateChildNodes(true);\r\n        }\r\n        else {\r\n            this.appendChild(newText);\r\n            this.updateChildNodes();\r\n        }\r\n    }\r\n    /**\r\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore\r\n     * @scenario\r\n     * [A,B,C]\r\n     *   1. insert D before C, D has no parent\r\n     *   2. insert D before C, D has the same parent of C\r\n     *   3. insert D before C, D has the different parent of C\r\n     */\r\n    insertBefore(newChild, refChild, isReplace) {\r\n        if (newChild.nodeName === DOCUMENT_FRAGMENT) {\r\n            newChild.childNodes.reduceRight((previousValue, currentValue) => {\r\n                this.insertBefore(currentValue, previousValue);\r\n                return currentValue;\r\n            }, refChild);\r\n            return newChild;\r\n        }\r\n        // Parent release newChild\r\n        //   - cleanRef: false (No need to clean eventSource, because newChild is about to be inserted)\r\n        //   - update: true (Need to update parent.childNodes, because parent.childNodes is reordered)\r\n        newChild.remove({ cleanRef: false });\r\n        // Data structure\r\n        newChild.parentNode = this;\r\n        if (refChild) {\r\n            // insertBefore & replaceChild\r\n            const index = this.findIndex(refChild);\r\n            this.childNodes.splice(index, 0, newChild);\r\n        }\r\n        else {\r\n            // appendChild\r\n            this.childNodes.push(newChild);\r\n        }\r\n        // Serialization\r\n        if (!refChild || isReplace) {\r\n            // appendChild & replaceChild\r\n            this.enqueueUpdate({\r\n                path: newChild._path,\r\n                value: this.hydrate(newChild)\r\n            });\r\n        }\r\n        else {\r\n            // insertBefore\r\n            this.updateChildNodes();\r\n        }\r\n        MutationObserver.record({\r\n            type: \"childList\" /* CHILD_LIST */,\r\n            target: this,\r\n            addedNodes: [newChild],\r\n            removedNodes: isReplace\r\n                ? [refChild] /** replaceChild */\r\n                : [],\r\n            nextSibling: isReplace\r\n                ? refChild.nextSibling /** replaceChild */\r\n                : (refChild || null),\r\n            previousSibling: newChild.previousSibling\r\n        });\r\n        return newChild;\r\n    }\r\n    /**\r\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild\r\n     * @scenario\r\n     * [A,B,C]\r\n     *   1. append C, C has no parent\r\n     *   2. append C, C has the same parent of B\r\n     *   3. append C, C has the different parent of B\r\n     */\r\n    appendChild(newChild) {\r\n        return this.insertBefore(newChild);\r\n    }\r\n    /**\r\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/replaceChild\r\n     * @scenario\r\n     * [A,B,C]\r\n     *   1. replace B with C, C has no parent\r\n     *   2. replace B with C, C has no parent, C has the same parent of B\r\n     *   3. replace B with C, C has no parent, C has the different parent of B\r\n     */\r\n    replaceChild(newChild, oldChild) {\r\n        if (oldChild.parentNode !== this)\r\n            return;\r\n        // Insert the newChild\r\n        this.insertBefore(newChild, oldChild, true);\r\n        // Destroy the oldChild\r\n        //   - cleanRef: true (Need to clean eventSource, because the oldChild was detached from the DOM tree)\r\n        //   - update: false (No need to update parent.childNodes, because replace will not cause the parent.childNodes being reordered)\r\n        oldChild.remove({ doUpdate: false });\r\n        return oldChild;\r\n    }\r\n    /**\r\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/removeChild\r\n     * @scenario\r\n     * [A,B,C]\r\n     *   1. remove A or B\r\n     *   2. remove C\r\n     */\r\n    removeChild(child, options = {}) {\r\n        const { cleanRef, doUpdate } = options;\r\n        if (cleanRef !== false && doUpdate !== false) {\r\n            // appendChild/replaceChild/insertBefore 不应该触发\r\n            // @Todo: 但其实如果 newChild 的父节点是另一颗子树的节点，应该是要触发的\r\n            MutationObserver.record({\r\n                type: \"childList\" /* CHILD_LIST */,\r\n                target: this,\r\n                removedNodes: [child],\r\n                nextSibling: child.nextSibling,\r\n                previousSibling: child.previousSibling\r\n            });\r\n        }\r\n        // Data Structure\r\n        const index = this.findIndex(child);\r\n        this.childNodes.splice(index, 1);\r\n        child.parentNode = null;\r\n        // Set eventSource\r\n        if (cleanRef !== false) {\r\n            eventSource.removeNodeTree(child);\r\n        }\r\n        // Serialization\r\n        if (doUpdate !== false) {\r\n            this.updateChildNodes();\r\n        }\r\n        return child;\r\n    }\r\n    remove(options) {\r\n        var _a;\r\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this, options);\r\n    }\r\n    hasChildNodes() {\r\n        return this.childNodes.length > 0;\r\n    }\r\n    enqueueUpdate(payload) {\r\n        var _a;\r\n        (_a = this._root) === null || _a === void 0 ? void 0 : _a.enqueueUpdate(payload);\r\n    }\r\n    get ownerDocument() {\r\n        const document = this._getElement(ElementNames.Document)();\r\n        return document;\r\n    }\r\n};\r\nTaroNode = __decorate([\r\n    injectable(),\r\n    __metadata(\"design:paramtypes\", [])\r\n], TaroNode);\n\nlet TaroText = class TaroText extends TaroNode {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.nodeType = 3 /* TEXT_NODE */;\r\n        this.nodeName = '#text';\r\n    }\r\n    set textContent(text) {\r\n        MutationObserver.record({\r\n            target: this,\r\n            type: \"characterData\" /* CHARACTER_DATA */,\r\n            oldValue: this._value\r\n        });\r\n        this._value = text;\r\n        this.enqueueUpdate({\r\n            path: `${this._path}.${\"v\" /* Text */}`,\r\n            value: text\r\n        });\r\n    }\r\n    get textContent() {\r\n        return this._value;\r\n    }\r\n    set nodeValue(text) {\r\n        this.textContent = text;\r\n    }\r\n    get nodeValue() {\r\n        return this._value;\r\n    }\r\n    set data(text) {\r\n        this.textContent = text;\r\n    }\r\n    get data() {\r\n        return this._value;\r\n    }\r\n};\r\nTaroText = __decorate([\r\n    injectable()\r\n], TaroText);\n\n/*\r\n *\r\n * https://www.w3.org/Style/CSS/all-properties.en.html\r\n */\r\nconst styleProperties = [\r\n    'all',\r\n    'appearance',\r\n    'blockOverflow',\r\n    'blockSize',\r\n    'bottom',\r\n    'clear',\r\n    'contain',\r\n    'content',\r\n    'continue',\r\n    'cursor',\r\n    'direction',\r\n    'display',\r\n    'filter',\r\n    'float',\r\n    'gap',\r\n    'height',\r\n    'inset',\r\n    'isolation',\r\n    'left',\r\n    'letterSpacing',\r\n    'lightingColor',\r\n    'markerSide',\r\n    'mixBlendMode',\r\n    'opacity',\r\n    'order',\r\n    'position',\r\n    'quotes',\r\n    'resize',\r\n    'right',\r\n    'rowGap',\r\n    'tabSize',\r\n    'tableLayout',\r\n    'top',\r\n    'userSelect',\r\n    'verticalAlign',\r\n    'visibility',\r\n    'voiceFamily',\r\n    'volume',\r\n    'whiteSpace',\r\n    'widows',\r\n    'width',\r\n    'zIndex',\r\n    'pointerEvents'\r\n    /** 非常用 style */\r\n    // 'azimuth',\r\n    // 'backfaceVisibility',\r\n    // 'baselineShift',\r\n    // 'captionSide',\r\n    // 'chains',\r\n    // 'dominantBaseline',\r\n    // 'elevation',\r\n    // 'emptyCells',\r\n    // 'forcedColorAdjust',\r\n    // 'glyphOrientationVertical',\r\n    // 'hangingPunctuation',\r\n    // 'hyphenateCharacter',\r\n    // 'hyphens',\r\n    // 'imageOrientation',\r\n    // 'imageResolution',\r\n    // 'orphans',\r\n    // 'playDuring',\r\n    // 'pointerEvents',\r\n    // 'regionFragment',\r\n    // 'richness',\r\n    // 'running',\r\n    // 'scrollBehavior',\r\n    // 'speechRate',\r\n    // 'stress',\r\n    // 'stringSet',\r\n    // 'unicodeBidi',\r\n    // 'willChange',\r\n    // 'writingMode',\r\n];\r\n// 减少文件体积\r\nfunction combine(prefix, list, excludeSelf) {\r\n    !excludeSelf && styleProperties.push(prefix);\r\n    list.forEach(item => {\r\n        styleProperties.push(prefix + item);\r\n    });\r\n}\r\nconst color = 'Color';\r\nconst style = 'Style';\r\nconst width = 'Width';\r\nconst image = 'Image';\r\nconst size = 'Size';\r\nconst color_style_width = [color, style, width];\r\nconst fitlength_fitwidth_image = ['FitLength', 'FitWidth', image];\r\nconst fitlength_fitwidth_image_radius = [...fitlength_fitwidth_image, 'Radius'];\r\nconst color_style_width_fitlength_fitwidth_image = [...color_style_width, ...fitlength_fitwidth_image];\r\nconst endRadius_startRadius = ['EndRadius', 'StartRadius'];\r\nconst bottom_left_right_top = ['Bottom', 'Left', 'Right', 'Top'];\r\nconst end_start = ['End', 'Start'];\r\nconst content_items_self = ['Content', 'Items', 'Self'];\r\nconst blockSize_height_inlineSize_width = ['BlockSize', 'Height', 'InlineSize', width];\r\nconst after_before = ['After', 'Before'];\r\ncombine('borderBlock', color_style_width);\r\ncombine('borderBlockEnd', color_style_width);\r\ncombine('borderBlockStart', color_style_width);\r\ncombine('outline', [...color_style_width, 'Offset']);\r\ncombine('border', [...color_style_width, 'Boundary', 'Break', 'Collapse', 'Radius', 'Spacing']);\r\ncombine('borderFit', ['Length', width]);\r\ncombine('borderInline', color_style_width);\r\ncombine('borderInlineEnd', color_style_width);\r\ncombine('borderInlineStart', color_style_width);\r\ncombine('borderLeft', color_style_width_fitlength_fitwidth_image);\r\ncombine('borderRight', color_style_width_fitlength_fitwidth_image);\r\ncombine('borderTop', color_style_width_fitlength_fitwidth_image);\r\ncombine('borderBottom', color_style_width_fitlength_fitwidth_image);\r\ncombine('textDecoration', [color, style, 'Line']);\r\ncombine('textEmphasis', [color, style, 'Position']);\r\ncombine('scrollMargin', bottom_left_right_top);\r\ncombine('scrollPadding', bottom_left_right_top);\r\ncombine('padding', bottom_left_right_top);\r\ncombine('margin', [...bottom_left_right_top, 'Trim']);\r\ncombine('scrollMarginBlock', end_start);\r\ncombine('scrollMarginInline', end_start);\r\ncombine('scrollPaddingBlock', end_start);\r\ncombine('scrollPaddingInline', end_start);\r\ncombine('gridColumn', end_start);\r\ncombine('gridRow', end_start);\r\ncombine('insetBlock', end_start);\r\ncombine('insetInline', end_start);\r\ncombine('marginBlock', end_start);\r\ncombine('marginInline', end_start);\r\ncombine('paddingBlock', end_start);\r\ncombine('paddingInline', end_start);\r\ncombine('pause', after_before);\r\ncombine('cue', after_before);\r\ncombine('mask', ['Clip', 'Composite', image, 'Mode', 'Origin', 'Position', 'Repeat', size, 'Type']);\r\ncombine('borderImage', ['Outset', 'Repeat', 'Slice', 'Source', 'Transform', width]);\r\ncombine('maskBorder', ['Mode', 'Outset', 'Repeat', 'Slice', 'Source', width]);\r\ncombine('font', ['Family', 'FeatureSettings', 'Kerning', 'LanguageOverride', 'MaxSize', 'MinSize', 'OpticalSizing', 'Palette', size, 'SizeAdjust', 'Stretch', style, 'Weight', 'VariationSettings']);\r\ncombine('fontSynthesis', ['SmallCaps', style, 'Weight']);\r\ncombine('transform', ['Box', 'Origin', style]);\r\ncombine('background', [color, image, 'Attachment', 'BlendMode', 'Clip', 'Origin', 'Position', 'Repeat', size]);\r\ncombine('listStyle', [image, 'Position', 'Type']);\r\ncombine('scrollSnap', ['Align', 'Stop', 'Type']);\r\ncombine('grid', ['Area', 'AutoColumns', 'AutoFlow', 'AutoRows']);\r\ncombine('gridTemplate', ['Areas', 'Columns', 'Rows']);\r\ncombine('overflow', ['Block', 'Inline', 'Wrap', 'X', 'Y']);\r\ncombine('transition', ['Delay', 'Duration', 'Property', 'TimingFunction']);\r\ncombine('lineStacking', ['Ruby', 'Shift', 'Strategy']);\r\ncombine('color', ['Adjust', 'InterpolationFilters', 'Scheme']);\r\ncombine('textAlign', ['All', 'Last']);\r\ncombine('page', ['BreakAfter', 'BreakBefore', 'BreakInside']);\r\ncombine('speak', ['Header', 'Numeral', 'Punctuation']);\r\ncombine('animation', ['Delay', 'Direction', 'Duration', 'FillMode', 'IterationCount', 'Name', 'PlayState', 'TimingFunction']);\r\ncombine('flex', ['Basis', 'Direction', 'Flow', 'Grow', 'Shrink', 'Wrap']);\r\ncombine('offset', [...after_before, ...end_start, 'Anchor', 'Distance', 'Path', 'Position', 'Rotate']);\r\ncombine('fontVariant', ['Alternates', 'Caps', 'EastAsian', 'Emoji', 'Ligatures', 'Numeric', 'Position']);\r\ncombine('perspective', ['Origin']);\r\ncombine('pitch', ['Range']);\r\ncombine('clip', ['Path', 'Rule']);\r\ncombine('flow', ['From', 'Into']);\r\ncombine('align', ['Content', 'Items', 'Self'], true);\r\ncombine('alignment', ['Adjust', 'Baseline'], true);\r\ncombine('bookmark', ['Label', 'Level', 'State'], true);\r\ncombine('borderStart', endRadius_startRadius, true);\r\ncombine('borderEnd', endRadius_startRadius, true);\r\ncombine('borderCorner', ['Fit', image, 'ImageTransform'], true);\r\ncombine('borderTopLeft', fitlength_fitwidth_image_radius, true);\r\ncombine('borderTopRight', fitlength_fitwidth_image_radius, true);\r\ncombine('borderBottomLeft', fitlength_fitwidth_image_radius, true);\r\ncombine('borderBottomRight', fitlength_fitwidth_image_radius, true);\r\ncombine('column', ['s', 'Count', 'Fill', 'Gap', 'Rule', 'RuleColor', 'RuleStyle', 'RuleWidth', 'Span', width], true);\r\ncombine('break', [...after_before, 'Inside'], true);\r\ncombine('wrap', [...after_before, 'Flow', 'Inside', 'Through'], true);\r\ncombine('justify', content_items_self, true);\r\ncombine('place', content_items_self, true);\r\ncombine('max', [...blockSize_height_inlineSize_width, 'Lines'], true);\r\ncombine('min', blockSize_height_inlineSize_width, true);\r\ncombine('line', ['Break', 'Clamp', 'Grid', 'Height', 'Padding', 'Snap'], true);\r\ncombine('inline', ['BoxAlign', size, 'Sizing'], true);\r\ncombine('text', ['CombineUpright', 'GroupAlign', 'Height', 'Indent', 'Justify', 'Orientation', 'Overflow', 'Shadow', 'SpaceCollapse', 'SpaceTrim', 'Spacing', 'Transform', 'UnderlinePosition', 'Wrap'], true);\r\ncombine('shape', ['ImageThreshold', 'Inside', 'Margin', 'Outside'], true);\r\ncombine('word', ['Break', 'Spacing', 'Wrap'], true);\r\ncombine('nav', ['Down', 'Left', 'Right', 'Up'], true);\r\ncombine('object', ['Fit', 'Position'], true);\r\ncombine('box', ['DecorationBreak', 'Shadow', 'Sizing', 'Snap'], true);\n\nfunction setStyle(newVal, styleKey) {\r\n    const old = this[styleKey];\r\n    const oldCssTxt = this.cssText;\r\n    if (newVal) {\r\n        this._usedStyleProp.add(styleKey);\r\n    }\r\n    process.env.NODE_ENV !== 'production' && warn(isString(newVal) && newVal.length > PROPERTY_THRESHOLD, `Style 属性 ${styleKey} 的值数据量过大，可能会影响渲染性能，考虑使用 CSS 类或其它方案替代。`);\r\n    if (old !== newVal) {\r\n        this._value[styleKey] = newVal;\r\n        this._element.enqueueUpdate({\r\n            path: `${this._element._path}.${\"st\" /* Style */}`,\r\n            value: this.cssText\r\n        });\r\n        // @Todo:\r\n        //   el.style.cssText = 'x: y;m: n'（Bug: 触发两次）\r\n        //   el.style.cssText = 'x: y'（正常）\r\n        //   el.style.x = y（正常）\r\n        MutationObserver.record({\r\n            type: \"attributes\" /* ATTRIBUTES */,\r\n            target: this._element,\r\n            attributeName: 'style',\r\n            oldValue: oldCssTxt\r\n        });\r\n    }\r\n}\r\nfunction initStyle(ctor) {\r\n    const properties = {};\r\n    for (let i = 0; i < styleProperties.length; i++) {\r\n        const styleKey = styleProperties[i];\r\n        properties[styleKey] = {\r\n            get() {\r\n                return this._value[styleKey] || '';\r\n            },\r\n            set(newVal) {\r\n                setStyle.call(this, newVal, styleKey);\r\n            }\r\n        };\r\n    }\r\n    Object.defineProperties(ctor.prototype, properties);\r\n}\r\nfunction isCssVariable(propertyName) {\r\n    return /^--/.test(propertyName);\r\n}\r\nclass Style {\r\n    constructor(element) {\r\n        this._element = element;\r\n        this._usedStyleProp = new Set();\r\n        this._value = {};\r\n    }\r\n    setCssVariables(styleKey) {\r\n        this.hasOwnProperty(styleKey) || Object.defineProperty(this, styleKey, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => {\r\n                return this._value[styleKey] || '';\r\n            },\r\n            set: (newVal) => {\r\n                setStyle.call(this, newVal, styleKey);\r\n            }\r\n        });\r\n    }\r\n    get cssText() {\r\n        const texts = [];\r\n        this._usedStyleProp.forEach(key => {\r\n            const val = this[key];\r\n            if (!val)\r\n                return;\r\n            const styleName = isCssVariable(key) ? key : toDashed(key);\r\n            texts.push(`${styleName}: ${val};`);\r\n        });\r\n        return texts.join(' ');\r\n    }\r\n    set cssText(str) {\r\n        if (str == null) {\r\n            str = '';\r\n        }\r\n        this._usedStyleProp.forEach(prop => {\r\n            this.removeProperty(prop);\r\n        });\r\n        if (str === '') {\r\n            return;\r\n        }\r\n        const rules = str.split(';');\r\n        for (let i = 0; i < rules.length; i++) {\r\n            const rule = rules[i].trim();\r\n            if (rule === '') {\r\n                continue;\r\n            }\r\n            // 可能存在 'background: url(http:x/y/z)' 的情况\r\n            const [propName, ...valList] = rule.split(':');\r\n            const val = valList.join(':');\r\n            if (isUndefined(val)) {\r\n                continue;\r\n            }\r\n            this.setProperty(propName.trim(), val.trim());\r\n        }\r\n    }\r\n    setProperty(propertyName, value) {\r\n        if (propertyName[0] === '-') {\r\n            // 支持 webkit 属性或 css 变量\r\n            this.setCssVariables(propertyName);\r\n        }\r\n        else {\r\n            propertyName = toCamelCase(propertyName);\r\n        }\r\n        if (isUndefined(value)) {\r\n            return;\r\n        }\r\n        if (value === null || value === '') {\r\n            this.removeProperty(propertyName);\r\n        }\r\n        else {\r\n            this[propertyName] = value;\r\n        }\r\n    }\r\n    removeProperty(propertyName) {\r\n        propertyName = toCamelCase(propertyName);\r\n        if (!this._usedStyleProp.has(propertyName)) {\r\n            return '';\r\n        }\r\n        const value = this[propertyName];\r\n        this[propertyName] = '';\r\n        this._usedStyleProp.delete(propertyName);\r\n        return value;\r\n    }\r\n    getPropertyValue(propertyName) {\r\n        propertyName = toCamelCase(propertyName);\r\n        const value = this[propertyName];\r\n        if (!value) {\r\n            return '';\r\n        }\r\n        return value;\r\n    }\r\n}\r\ninitStyle(Style);\n\nfunction returnTrue() {\r\n    return true;\r\n}\r\nfunction treeToArray(root, predict) {\r\n    const array = [];\r\n    const filter = predict !== null && predict !== void 0 ? predict : returnTrue;\r\n    let object = root;\r\n    while (object) {\r\n        if (object.nodeType === 1 /* ELEMENT_NODE */ && filter(object)) {\r\n            array.push(object);\r\n        }\r\n        object = following(object, root);\r\n    }\r\n    return array;\r\n}\r\nfunction following(el, root) {\r\n    const firstChild = el.firstChild;\r\n    if (firstChild) {\r\n        return firstChild;\r\n    }\r\n    let current = el;\r\n    do {\r\n        if (current === root) {\r\n            return null;\r\n        }\r\n        const nextSibling = current.nextSibling;\r\n        if (nextSibling) {\r\n            return nextSibling;\r\n        }\r\n        current = current.parentElement;\r\n    } while (current);\r\n    return null;\r\n}\n\nclass ClassList extends Set {\r\n    constructor(className, el) {\r\n        super();\r\n        className.trim().split(/\\s+/).forEach(super.add.bind(this));\r\n        this.el = el;\r\n    }\r\n    get value() {\r\n        return [...this].filter(v => v !== '').join(' ');\r\n    }\r\n    add(s) {\r\n        super.add(s);\r\n        this._update();\r\n        return this;\r\n    }\r\n    get length() {\r\n        return this.size;\r\n    }\r\n    remove(s) {\r\n        super.delete(s);\r\n        this._update();\r\n    }\r\n    toggle(s) {\r\n        if (super.has(s)) {\r\n            super.delete(s);\r\n        }\r\n        else {\r\n            super.add(s);\r\n        }\r\n        this._update();\r\n    }\r\n    replace(s1, s2) {\r\n        super.delete(s1);\r\n        super.add(s2);\r\n        this._update();\r\n    }\r\n    contains(s) {\r\n        return super.has(s);\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n    _update() {\r\n        this.el.className = this.value;\r\n    }\r\n}\n\nlet TaroElement = class TaroElement extends TaroNode {\r\n    constructor() {\r\n        var _a, _b;\r\n        super();\r\n        this.props = {};\r\n        this.dataset = EMPTY_OBJ;\r\n        const impl = getElementImpl();\r\n        impl.bind(this);\r\n        this.nodeType = 1 /* ELEMENT_NODE */;\r\n        this.style = new Style(this);\r\n        (_b = (_a = this.hooks).patchElement) === null || _b === void 0 ? void 0 : _b.call(_a, this);\r\n    }\r\n    _stopPropagation(event) {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        let target = this;\r\n        // eslint-disable-next-line no-cond-assign\r\n        while ((target = target.parentNode)) {\r\n            const listeners = target.__handlers[event.type];\r\n            if (!isArray(listeners)) {\r\n                continue;\r\n            }\r\n            for (let i = listeners.length; i--;) {\r\n                const l = listeners[i];\r\n                l._stop = true;\r\n            }\r\n        }\r\n    }\r\n    get id() {\r\n        return this.getAttribute(ID);\r\n    }\r\n    set id(val) {\r\n        this.setAttribute(ID, val);\r\n    }\r\n    get className() {\r\n        return this.getAttribute(CLASS) || '';\r\n    }\r\n    set className(val) {\r\n        this.setAttribute(CLASS, val);\r\n    }\r\n    get cssText() {\r\n        return this.getAttribute(STYLE) || '';\r\n    }\r\n    get classList() {\r\n        return new ClassList(this.className, this);\r\n    }\r\n    get children() {\r\n        return this.childNodes.filter(isElement);\r\n    }\r\n    get attributes() {\r\n        const props = this.props;\r\n        const propKeys = Object.keys(props);\r\n        const style = this.style.cssText;\r\n        const attrs = propKeys.map(key => ({ name: key, value: props[key] }));\r\n        return attrs.concat(style ? { name: STYLE, value: style } : []);\r\n    }\r\n    get textContent() {\r\n        let text = '';\r\n        const childNodes = this.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            text += childNodes[i].textContent;\r\n        }\r\n        return text;\r\n    }\r\n    set textContent(text) {\r\n        super.textContent = text;\r\n    }\r\n    hasAttribute(qualifiedName) {\r\n        return !isUndefined(this.props[qualifiedName]);\r\n    }\r\n    hasAttributes() {\r\n        return this.attributes.length > 0;\r\n    }\r\n    get focus() {\r\n        return function () {\r\n            this.setAttribute(FOCUS, true);\r\n        };\r\n    }\r\n    // 兼容 Vue3，详情请见：https://github.com/NervJS/taro/issues/10579\r\n    set focus(value) {\r\n        this.setAttribute(FOCUS, value);\r\n    }\r\n    blur() {\r\n        this.setAttribute(FOCUS, false);\r\n    }\r\n    setAttribute(qualifiedName, value) {\r\n        var _a, _b;\r\n        process.env.NODE_ENV !== 'production' && warn(isString(value) && value.length > PROPERTY_THRESHOLD, `元素 ${this.nodeName} 的 属性 ${qualifiedName} 的值数据量过大，可能会影响渲染性能。考虑降低图片转为 base64 的阈值或在 CSS 中使用 base64。`);\r\n        const isPureView = this.nodeName === VIEW && !isHasExtractProp(this) && !this.isAnyEventBinded();\r\n        if (qualifiedName !== STYLE) {\r\n            MutationObserver.record({\r\n                target: this,\r\n                type: \"attributes\" /* ATTRIBUTES */,\r\n                attributeName: qualifiedName,\r\n                oldValue: this.getAttribute(qualifiedName)\r\n            });\r\n        }\r\n        switch (qualifiedName) {\r\n            case STYLE:\r\n                this.style.cssText = value;\r\n                break;\r\n            case ID:\r\n                if (this.uid !== this.sid) {\r\n                    // eventSource[sid] 永远保留，直到组件卸载\r\n                    // eventSource[uid] 可变\r\n                    eventSource.delete(this.uid);\r\n                }\r\n                value = String(value);\r\n                this.props[qualifiedName] = this.uid = value;\r\n                eventSource.set(value, this);\r\n                break;\r\n            default:\r\n                this.props[qualifiedName] = value;\r\n                if (qualifiedName.startsWith('data-')) {\r\n                    if (this.dataset === EMPTY_OBJ) {\r\n                        this.dataset = Object.create(null);\r\n                    }\r\n                    this.dataset[toCamelCase(qualifiedName.replace(/^data-/, ''))] = value;\r\n                }\r\n                break;\r\n        }\r\n        qualifiedName = shortcutAttr(qualifiedName);\r\n        const payload = {\r\n            path: `${this._path}.${toCamelCase(qualifiedName)}`,\r\n            value: isFunction(value) ? () => value : value\r\n        };\r\n        (_b = (_a = this.hooks).modifySetAttrPayload) === null || _b === void 0 ? void 0 : _b.call(_a, this, qualifiedName, payload);\r\n        this.enqueueUpdate(payload);\r\n        if (this.nodeName === VIEW) {\r\n            if (toCamelCase(qualifiedName) === CATCHMOVE) {\r\n                // catchMove = true: catch-view\r\n                // catchMove = false: view or static-view\r\n                this.enqueueUpdate({\r\n                    path: `${this._path}.${\"nn\" /* NodeName */}`,\r\n                    value: value ? CATCH_VIEW : (this.isAnyEventBinded() ? VIEW : STATIC_VIEW)\r\n                });\r\n            }\r\n            else if (isPureView && isHasExtractProp(this)) {\r\n                // pure-view => static-view\r\n                this.enqueueUpdate({\r\n                    path: `${this._path}.${\"nn\" /* NodeName */}`,\r\n                    value: STATIC_VIEW\r\n                });\r\n            }\r\n        }\r\n    }\r\n    removeAttribute(qualifiedName) {\r\n        var _a, _b, _c, _d;\r\n        const isStaticView = this.nodeName === VIEW && isHasExtractProp(this) && !this.isAnyEventBinded();\r\n        MutationObserver.record({\r\n            target: this,\r\n            type: \"attributes\" /* ATTRIBUTES */,\r\n            attributeName: qualifiedName,\r\n            oldValue: this.getAttribute(qualifiedName)\r\n        });\r\n        if (qualifiedName === STYLE) {\r\n            this.style.cssText = '';\r\n        }\r\n        else {\r\n            const isInterrupt = (_b = (_a = this.hooks).onRemoveAttribute) === null || _b === void 0 ? void 0 : _b.call(_a, this, qualifiedName);\r\n            if (isInterrupt) {\r\n                return;\r\n            }\r\n            if (!this.props.hasOwnProperty(qualifiedName)) {\r\n                return;\r\n            }\r\n            delete this.props[qualifiedName];\r\n        }\r\n        qualifiedName = shortcutAttr(qualifiedName);\r\n        const payload = {\r\n            path: `${this._path}.${toCamelCase(qualifiedName)}`,\r\n            value: ''\r\n        };\r\n        (_d = (_c = this.hooks).modifyRmAttrPayload) === null || _d === void 0 ? void 0 : _d.call(_c, this, qualifiedName, payload);\r\n        this.enqueueUpdate(payload);\r\n        if (this.nodeName === VIEW) {\r\n            if (toCamelCase(qualifiedName) === CATCHMOVE) {\r\n                // catch-view => view or static-view or pure-view\r\n                this.enqueueUpdate({\r\n                    path: `${this._path}.${\"nn\" /* NodeName */}`,\r\n                    value: this.isAnyEventBinded() ? VIEW : (isHasExtractProp(this) ? STATIC_VIEW : PURE_VIEW)\r\n                });\r\n            }\r\n            else if (isStaticView && !isHasExtractProp(this)) {\r\n                // static-view => pure-view\r\n                this.enqueueUpdate({\r\n                    path: `${this._path}.${\"nn\" /* NodeName */}`,\r\n                    value: PURE_VIEW\r\n                });\r\n            }\r\n        }\r\n    }\r\n    getAttribute(qualifiedName) {\r\n        const attr = qualifiedName === STYLE ? this.style.cssText : this.props[qualifiedName];\r\n        return attr !== null && attr !== void 0 ? attr : '';\r\n    }\r\n    getElementsByTagName(tagName) {\r\n        return treeToArray(this, (el) => {\r\n            return el.nodeName === tagName || (tagName === '*' && this !== el);\r\n        });\r\n    }\r\n    getElementsByClassName(className) {\r\n        return treeToArray(this, (el) => {\r\n            const classList = el.classList;\r\n            const classNames = className.trim().split(/\\s+/);\r\n            return classNames.every(c => classList.has(c));\r\n        });\r\n    }\r\n    dispatchEvent(event) {\r\n        const cancelable = event.cancelable;\r\n        const listeners = this.__handlers[event.type];\r\n        if (!isArray(listeners)) {\r\n            return false;\r\n        }\r\n        for (let i = listeners.length; i--;) {\r\n            const listener = listeners[i];\r\n            let result;\r\n            if (listener._stop) {\r\n                listener._stop = false;\r\n            }\r\n            else {\r\n                this.hooks.modifyDispatchEvent(event, this);\r\n                result = listener.call(this, event);\r\n            }\r\n            if ((result === false || event._end) && cancelable) {\r\n                event.defaultPrevented = true;\r\n            }\r\n            if (event._end && event._stop) {\r\n                break;\r\n            }\r\n        }\r\n        if (event._stop) {\r\n            this._stopPropagation(event);\r\n        }\r\n        else {\r\n            event._stop = true;\r\n        }\r\n        return listeners != null;\r\n    }\r\n    addEventListener(type, handler, options) {\r\n        const name = this.nodeName;\r\n        const SPECIAL_NODES = this.hooks.getSpecialNodes();\r\n        if (!this.isAnyEventBinded() && SPECIAL_NODES.indexOf(name) > -1) {\r\n            this.enqueueUpdate({\r\n                path: `${this._path}.${\"nn\" /* NodeName */}`,\r\n                value: name\r\n            });\r\n        }\r\n        super.addEventListener(type, handler, options);\r\n    }\r\n    removeEventListener(type, handler) {\r\n        super.removeEventListener(type, handler);\r\n        const name = this.nodeName;\r\n        const SPECIAL_NODES = this.hooks.getSpecialNodes();\r\n        if (!this.isAnyEventBinded() && SPECIAL_NODES.indexOf(name) > -1) {\r\n            this.enqueueUpdate({\r\n                path: `${this._path}.${\"nn\" /* NodeName */}`,\r\n                value: isHasExtractProp(this) ? `static-${name}` : `pure-${name}`\r\n            });\r\n        }\r\n    }\r\n};\r\nTaroElement = __decorate([\r\n    injectable(),\r\n    __metadata(\"design:paramtypes\", [])\r\n], TaroElement);\n\nconst options = {\r\n    prerender: true,\r\n    debug: false\r\n};\n\nclass Performance {\r\n    constructor() {\r\n        this.recorder = new Map();\r\n    }\r\n    start(id) {\r\n        if (!options.debug) {\r\n            return;\r\n        }\r\n        this.recorder.set(id, Date.now());\r\n    }\r\n    stop(id) {\r\n        if (!options.debug) {\r\n            return;\r\n        }\r\n        const now = Date.now();\r\n        const prev = this.recorder.get(id);\r\n        const time = now - prev;\r\n        // eslint-disable-next-line no-console\r\n        console.log(`${id} 时长： ${time}ms`);\r\n    }\r\n}\r\nconst perf = new Performance();\n\nfunction findCustomWrapper(root, dataPathArr) {\r\n    // ['root', 'cn', '[0]'] remove 'root' => ['cn', '[0]']\r\n    const list = dataPathArr.slice(1);\r\n    let currentData = root;\r\n    let customWrapper;\r\n    let splitedPath = '';\r\n    list.some((item, i) => {\r\n        const key = item\r\n            // '[0]' => '0'\r\n            .replace(/^\\[(.+)\\]$/, '$1')\r\n            // 'cn' => 'childNodes'\r\n            .replace(/\\bcn\\b/g, 'childNodes');\r\n        currentData = currentData[key];\r\n        if (isUndefined(currentData))\r\n            return true;\r\n        if (currentData.nodeName === CUSTOM_WRAPPER) {\r\n            const res = customWrapperCache.get(currentData.sid);\r\n            if (res) {\r\n                customWrapper = res;\r\n                splitedPath = dataPathArr.slice(i + 2).join('.');\r\n            }\r\n        }\r\n    });\r\n    if (customWrapper) {\r\n        return {\r\n            customWrapper,\r\n            splitedPath\r\n        };\r\n    }\r\n}\r\nlet TaroRootElement = class TaroRootElement extends TaroElement {\r\n    constructor() {\r\n        super();\r\n        this.updatePayloads = [];\r\n        this.updateCallbacks = [];\r\n        this.pendingUpdate = false;\r\n        this.ctx = null;\r\n        this.nodeName = ROOT_STR;\r\n    }\r\n    get _path() {\r\n        return ROOT_STR;\r\n    }\r\n    get _root() {\r\n        return this;\r\n    }\r\n    enqueueUpdate(payload) {\r\n        this.updatePayloads.push(payload);\r\n        if (!this.pendingUpdate && this.ctx) {\r\n            this.performUpdate();\r\n        }\r\n    }\r\n    performUpdate(initRender = false, prerender) {\r\n        this.pendingUpdate = true;\r\n        const ctx = this.ctx;\r\n        setTimeout(() => {\r\n            perf.start(SET_DATA);\r\n            const data = Object.create(null);\r\n            const resetPaths = new Set(initRender\r\n                ? ['root.cn.[0]', 'root.cn[0]']\r\n                : []);\r\n            while (this.updatePayloads.length > 0) {\r\n                const { path, value } = this.updatePayloads.shift();\r\n                if (path.endsWith(\"cn\" /* Childnodes */)) {\r\n                    resetPaths.add(path);\r\n                }\r\n                data[path] = value;\r\n            }\r\n            for (const path in data) {\r\n                resetPaths.forEach(p => {\r\n                    // 已经重置了数组，就不需要分别再设置了\r\n                    if (path.includes(p) && path !== p) {\r\n                        delete data[path];\r\n                    }\r\n                });\r\n                const value = data[path];\r\n                if (isFunction(value)) {\r\n                    data[path] = value();\r\n                }\r\n            }\r\n            // 预渲染\r\n            if (isFunction(prerender))\r\n                return prerender(data);\r\n            // 正常渲染\r\n            this.pendingUpdate = false;\r\n            let normalUpdate = {};\r\n            const customWrapperMap = new Map();\r\n            if (initRender) {\r\n                // 初次渲染，使用页面级别的 setData\r\n                normalUpdate = data;\r\n            }\r\n            else {\r\n                // 更新渲染，区分 CustomWrapper 与页面级别的 setData\r\n                for (const p in data) {\r\n                    const dataPathArr = p.split('.');\r\n                    const found = findCustomWrapper(this, dataPathArr);\r\n                    if (found) {\r\n                        // 此项数据使用 CustomWrapper 去更新\r\n                        const { customWrapper, splitedPath } = found;\r\n                        // 合并同一个 customWrapper 的相关更新到一次 setData 中\r\n                        customWrapperMap.set(customWrapper, Object.assign(Object.assign({}, (customWrapperMap.get(customWrapper) || {})), { [`i.${splitedPath}`]: data[p] }));\r\n                    }\r\n                    else {\r\n                        // 此项数据使用页面去更新\r\n                        normalUpdate[p] = data[p];\r\n                    }\r\n                }\r\n            }\r\n            const customWrpperCount = customWrapperMap.size;\r\n            const isNeedNormalUpdate = Object.keys(normalUpdate).length > 0;\r\n            const updateArrLen = customWrpperCount + (isNeedNormalUpdate ? 1 : 0);\r\n            let executeTime = 0;\r\n            const cb = () => {\r\n                if (++executeTime === updateArrLen) {\r\n                    perf.stop(SET_DATA);\r\n                    this.flushUpdateCallback();\r\n                    initRender && perf.stop(PAGE_INIT);\r\n                }\r\n            };\r\n            // custom-wrapper setData\r\n            if (customWrpperCount) {\r\n                customWrapperMap.forEach((data, ctx) => {\r\n                    if (process.env.NODE_ENV !== 'production' && options.debug) {\r\n                        // eslint-disable-next-line no-console\r\n                        console.log('custom wrapper setData: ', data);\r\n                    }\r\n                    ctx.setData(data, cb);\r\n                });\r\n            }\r\n            // page setData\r\n            if (isNeedNormalUpdate) {\r\n                if (process.env.NODE_ENV !== 'production' && options.debug) {\r\n                    // eslint-disable-next-line no-console\r\n                    console.log('page setData:', normalUpdate);\r\n                }\r\n                ctx.setData(normalUpdate, cb);\r\n            }\r\n        }, 0);\r\n    }\r\n    enqueueUpdateCallback(cb, ctx) {\r\n        this.updateCallbacks.push(() => {\r\n            ctx ? cb.call(ctx) : cb();\r\n        });\r\n    }\r\n    flushUpdateCallback() {\r\n        const updateCallbacks = this.updateCallbacks;\r\n        if (!updateCallbacks.length)\r\n            return;\r\n        const copies = updateCallbacks.slice(0);\r\n        this.updateCallbacks.length = 0;\r\n        for (let i = 0; i < copies.length; i++) {\r\n            copies[i]();\r\n        }\r\n    }\r\n};\r\nTaroRootElement = __decorate([\r\n    injectable(),\r\n    __metadata(\"design:paramtypes\", [])\r\n], TaroRootElement);\n\nclass FormElement extends TaroElement {\r\n    get value() {\r\n        // eslint-disable-next-line dot-notation\r\n        const val = this.props[VALUE];\r\n        return val == null ? '' : val;\r\n    }\r\n    set value(val) {\r\n        this.setAttribute(VALUE, val);\r\n    }\r\n    dispatchEvent(event) {\r\n        if (event.mpEvent) {\r\n            const val = event.mpEvent.detail.value;\r\n            if (event.type === CHANGE) {\r\n                this.props.value = val;\r\n            }\r\n            else if (event.type === INPUT) {\r\n                // Web 规范中表单组件的 value 应该跟着输入改变\r\n                // 只是改 this.props.value 的话不会进行 setData，因此这里修改 this.value。\r\n                // 只测试了 React、Vue、Vue3 input 组件的 onInput 事件，onChange 事件不确定有没有副作用，所以暂不修改。\r\n                this.value = val;\r\n            }\r\n        }\r\n        return super.dispatchEvent(event);\r\n    }\r\n}\n\n// for Vue3\r\nclass SVGElement extends TaroElement {\r\n}\n\n// Taro 事件对象。以 Web 标准的事件对象为基础，加入小程序事件对象中携带的部分信息，并模拟实现事件冒泡。\r\nclass TaroEvent {\r\n    constructor(type, opts, event) {\r\n        this._stop = false;\r\n        this._end = false;\r\n        this.defaultPrevented = false;\r\n        // timestamp can either be hi-res ( relative to page load) or low-res (relative to UNIX epoch)\r\n        // here use hi-res timestamp\r\n        this.timeStamp = Date.now();\r\n        this.type = type.toLowerCase();\r\n        this.mpEvent = event;\r\n        this.bubbles = Boolean(opts && opts.bubbles);\r\n        this.cancelable = Boolean(opts && opts.cancelable);\r\n    }\r\n    stopPropagation() {\r\n        this._stop = true;\r\n    }\r\n    stopImmediatePropagation() {\r\n        this._end = this._stop = true;\r\n    }\r\n    preventDefault() {\r\n        this.defaultPrevented = true;\r\n    }\r\n    get target() {\r\n        var _a, _b;\r\n        const target = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.target) || null);\r\n        const element = getDocument().getElementById(target.id);\r\n        target.dataset = element !== null ? element.dataset : EMPTY_OBJ;\r\n        for (const key in (_b = this.mpEvent) === null || _b === void 0 ? void 0 : _b.detail) {\r\n            target[key] = this.mpEvent.detail[key];\r\n        }\r\n        return target;\r\n    }\r\n    get currentTarget() {\r\n        var _a, _b;\r\n        const currentTarget = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.currentTarget) || null);\r\n        const element = getDocument().getElementById(currentTarget.id);\r\n        if (element === null) {\r\n            return this.target;\r\n        }\r\n        currentTarget.dataset = element.dataset;\r\n        for (const key in (_b = this.mpEvent) === null || _b === void 0 ? void 0 : _b.detail) {\r\n            currentTarget[key] = this.mpEvent.detail[key];\r\n        }\r\n        return currentTarget;\r\n    }\r\n}\r\nfunction createEvent(event, node) {\r\n    if (typeof event === 'string') {\r\n        // For Vue3 using document.createEvent\r\n        return new TaroEvent(event, { bubbles: true, cancelable: true });\r\n    }\r\n    const domEv = new TaroEvent(event.type, { bubbles: true, cancelable: true }, event);\r\n    for (const key in event) {\r\n        if (key === CURRENT_TARGET || key === TARGET || key === TYPE || key === TIME_STAMP) {\r\n            continue;\r\n        }\r\n        else {\r\n            domEv[key] = event[key];\r\n        }\r\n    }\r\n    if (domEv.type === CONFIRM && (node === null || node === void 0 ? void 0 : node.nodeName) === INPUT) {\r\n        // eslint-disable-next-line dot-notation\r\n        domEv[KEY_CODE] = 13;\r\n    }\r\n    return domEv;\r\n}\r\nconst eventsBatch = {};\r\n// 小程序的事件代理回调函数\r\nfunction eventHandler(event) {\r\n    var _a, _b;\r\n    const hooks = getHooks();\r\n    (_a = hooks.modifyMpEvent) === null || _a === void 0 ? void 0 : _a.call(hooks, event);\r\n    event.currentTarget || (event.currentTarget = event.target);\r\n    const currentTarget = event.currentTarget;\r\n    const id = ((_b = currentTarget.dataset) === null || _b === void 0 ? void 0 : _b.sid /** sid */) || currentTarget.id /** uid */ || '';\r\n    const node = getDocument().getElementById(id);\r\n    if (node) {\r\n        const dispatch = () => {\r\n            var _a;\r\n            const e = createEvent(event, node);\r\n            (_a = hooks.modifyTaroEvent) === null || _a === void 0 ? void 0 : _a.call(hooks, e, node);\r\n            node.dispatchEvent(e);\r\n        };\r\n        if (isFunction(hooks.batchedEventUpdates)) {\r\n            const type = event.type;\r\n            if (!hooks.isBubbleEvents(type) ||\r\n                !isParentBinded(node, type) ||\r\n                (type === TOUCHMOVE && !!node.props.catchMove)) {\r\n                // 最上层组件统一 batchUpdate\r\n                hooks.batchedEventUpdates(() => {\r\n                    if (eventsBatch[type]) {\r\n                        eventsBatch[type].forEach(fn => fn());\r\n                        delete eventsBatch[type];\r\n                    }\r\n                    dispatch();\r\n                });\r\n            }\r\n            else {\r\n                // 如果上层组件也有绑定同类型的组件，委托给上层组件调用事件回调\r\n                (eventsBatch[type] || (eventsBatch[type] = [])).push(dispatch);\r\n            }\r\n        }\r\n        else {\r\n            dispatch();\r\n        }\r\n    }\r\n}\n\nconst doc = process.env.TARO_ENV === 'h5' ? document : EMPTY_OBJ;\r\nconst win = process.env.TARO_ENV === 'h5' ? window : EMPTY_OBJ;\n\nfunction initPosition() {\r\n    return {\r\n        index: 0,\r\n        column: 0,\r\n        line: 0\r\n    };\r\n}\r\nfunction feedPosition(position, str, len) {\r\n    const start = position.index;\r\n    const end = position.index = start + len;\r\n    for (let i = start; i < end; i++) {\r\n        const char = str.charAt(i);\r\n        if (char === '\\n') {\r\n            position.line++;\r\n            position.column = 0;\r\n        }\r\n        else {\r\n            position.column++;\r\n        }\r\n    }\r\n}\r\nfunction jumpPosition(position, str, end) {\r\n    const len = end - position.index;\r\n    return feedPosition(position, str, len);\r\n}\r\nfunction copyPosition(position) {\r\n    return {\r\n        index: position.index,\r\n        line: position.line,\r\n        column: position.column\r\n    };\r\n}\r\nconst whitespace = /\\s/;\r\nfunction isWhitespaceChar(char) {\r\n    return whitespace.test(char);\r\n}\r\nconst equalSign = /=/;\r\nfunction isEqualSignChar(char) {\r\n    return equalSign.test(char);\r\n}\r\nfunction shouldBeIgnore(tagName) {\r\n    const name = tagName.toLowerCase();\r\n    if (options.html.skipElements.has(name)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nconst alphanumeric = /[A-Za-z0-9]/;\r\nfunction findTextEnd(str, index) {\r\n    while (true) {\r\n        const textEnd = str.indexOf('<', index);\r\n        if (textEnd === -1) {\r\n            return textEnd;\r\n        }\r\n        const char = str.charAt(textEnd + 1);\r\n        if (char === '/' || char === '!' || alphanumeric.test(char)) {\r\n            return textEnd;\r\n        }\r\n        index = textEnd + 1;\r\n    }\r\n}\r\nfunction isWordEnd(cursor, wordBegin, html) {\r\n    if (!isWhitespaceChar(html.charAt(cursor)))\r\n        return false;\r\n    const len = html.length;\r\n    // backwrad\r\n    for (let i = cursor - 1; i > wordBegin; i--) {\r\n        const char = html.charAt(i);\r\n        if (!isWhitespaceChar(char)) {\r\n            if (isEqualSignChar(char))\r\n                return false;\r\n            break;\r\n        }\r\n    }\r\n    // forward\r\n    for (let i = cursor + 1; i < len; i++) {\r\n        const char = html.charAt(i);\r\n        if (!isWhitespaceChar(char)) {\r\n            if (isEqualSignChar(char))\r\n                return false;\r\n            return true;\r\n        }\r\n    }\r\n}\r\nclass Scaner {\r\n    constructor(html) {\r\n        this.tokens = [];\r\n        this.position = initPosition();\r\n        this.html = html;\r\n    }\r\n    scan() {\r\n        const { html, position } = this;\r\n        const len = html.length;\r\n        while (position.index < len) {\r\n            const start = position.index;\r\n            this.scanText();\r\n            if (position.index === start) {\r\n                const isComment = html.startsWith('!--', start + 1);\r\n                if (isComment) {\r\n                    this.scanComment();\r\n                }\r\n                else {\r\n                    const tagName = this.scanTag();\r\n                    if (shouldBeIgnore(tagName)) {\r\n                        this.scanSkipTag(tagName);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this.tokens;\r\n    }\r\n    scanText() {\r\n        const type = 'text';\r\n        const { html, position } = this;\r\n        let textEnd = findTextEnd(html, position.index);\r\n        if (textEnd === position.index) {\r\n            return;\r\n        }\r\n        if (textEnd === -1) {\r\n            textEnd = html.length;\r\n        }\r\n        const start = copyPosition(position);\r\n        const content = html.slice(position.index, textEnd);\r\n        jumpPosition(position, html, textEnd);\r\n        const end = copyPosition(position);\r\n        this.tokens.push({ type, content, position: { start, end } });\r\n    }\r\n    scanComment() {\r\n        const type = 'comment';\r\n        const { html, position } = this;\r\n        const start = copyPosition(position);\r\n        feedPosition(position, html, 4); // \"<!--\".length\r\n        let contentEnd = html.indexOf('-->', position.index);\r\n        let commentEnd = contentEnd + 3; // \"-->\".length\r\n        if (contentEnd === -1) {\r\n            contentEnd = commentEnd = html.length;\r\n        }\r\n        const content = html.slice(position.index, contentEnd);\r\n        jumpPosition(position, html, commentEnd);\r\n        this.tokens.push({\r\n            type,\r\n            content,\r\n            position: {\r\n                start,\r\n                end: copyPosition(position)\r\n            }\r\n        });\r\n    }\r\n    scanTag() {\r\n        this.scanTagStart();\r\n        const tagName = this.scanTagName();\r\n        this.scanAttrs();\r\n        this.scanTagEnd();\r\n        return tagName;\r\n    }\r\n    scanTagStart() {\r\n        const type = 'tag-start';\r\n        const { html, position } = this;\r\n        const secondChar = html.charAt(position.index + 1);\r\n        const close = secondChar === '/';\r\n        const start = copyPosition(position);\r\n        feedPosition(position, html, close ? 2 : 1);\r\n        this.tokens.push({ type, close, position: { start } });\r\n    }\r\n    scanTagEnd() {\r\n        const type = 'tag-end';\r\n        const { html, position } = this;\r\n        const firstChar = html.charAt(position.index);\r\n        const close = firstChar === '/';\r\n        feedPosition(position, html, close ? 2 : 1);\r\n        const end = copyPosition(position);\r\n        this.tokens.push({ type, close, position: { end } });\r\n    }\r\n    scanTagName() {\r\n        const type = 'tag';\r\n        const { html, position } = this;\r\n        const len = html.length;\r\n        let start = position.index;\r\n        while (start < len) {\r\n            const char = html.charAt(start);\r\n            const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\r\n            if (isTagChar)\r\n                break;\r\n            start++;\r\n        }\r\n        let end = start + 1;\r\n        while (end < len) {\r\n            const char = html.charAt(end);\r\n            const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\r\n            if (!isTagChar)\r\n                break;\r\n            end++;\r\n        }\r\n        jumpPosition(position, html, end);\r\n        const tagName = html.slice(start, end);\r\n        this.tokens.push({\r\n            type,\r\n            content: tagName\r\n        });\r\n        return tagName;\r\n    }\r\n    scanAttrs() {\r\n        const { html, position, tokens } = this;\r\n        let cursor = position.index;\r\n        let quote = null; // null, single-, or double-quote\r\n        let wordBegin = cursor; // index of word start\r\n        const words = []; // \"key\", \"key=value\", \"key='value'\", etc\r\n        const len = html.length;\r\n        while (cursor < len) {\r\n            const char = html.charAt(cursor);\r\n            if (quote) {\r\n                const isQuoteEnd = char === quote;\r\n                if (isQuoteEnd) {\r\n                    quote = null;\r\n                }\r\n                cursor++;\r\n                continue;\r\n            }\r\n            const isTagEnd = char === '/' || char === '>';\r\n            if (isTagEnd) {\r\n                if (cursor !== wordBegin) {\r\n                    words.push(html.slice(wordBegin, cursor));\r\n                }\r\n                break;\r\n            }\r\n            if (isWordEnd(cursor, wordBegin, html)) {\r\n                if (cursor !== wordBegin) {\r\n                    words.push(html.slice(wordBegin, cursor));\r\n                }\r\n                wordBegin = cursor + 1;\r\n                cursor++;\r\n                continue;\r\n            }\r\n            const isQuoteStart = char === '\\'' || char === '\"';\r\n            if (isQuoteStart) {\r\n                quote = char;\r\n                cursor++;\r\n                continue;\r\n            }\r\n            cursor++;\r\n        }\r\n        jumpPosition(position, html, cursor);\r\n        const wLen = words.length;\r\n        const type = 'attribute';\r\n        for (let i = 0; i < wLen; i++) {\r\n            const word = words[i];\r\n            const isNotPair = word.includes('=');\r\n            if (isNotPair) {\r\n                const secondWord = words[i + 1];\r\n                if (secondWord && secondWord.startsWith('=')) {\r\n                    if (secondWord.length > 1) {\r\n                        const newWord = word + secondWord;\r\n                        tokens.push({ type, content: newWord });\r\n                        i += 1;\r\n                        continue;\r\n                    }\r\n                    const thirdWord = words[i + 2];\r\n                    i += 1;\r\n                    if (thirdWord) {\r\n                        const newWord = word + '=' + thirdWord;\r\n                        tokens.push({ type, content: newWord });\r\n                        i += 1;\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            if (word.endsWith('=')) {\r\n                const secondWord = words[i + 1];\r\n                if (secondWord && !secondWord.includes('=')) {\r\n                    const newWord = word + secondWord;\r\n                    tokens.push({ type, content: newWord });\r\n                    i += 1;\r\n                    continue;\r\n                }\r\n                const newWord = word.slice(0, -1);\r\n                tokens.push({ type, content: newWord });\r\n                continue;\r\n            }\r\n            tokens.push({ type, content: word });\r\n        }\r\n    }\r\n    scanSkipTag(tagName) {\r\n        const { html, position } = this;\r\n        const safeTagName = tagName.toLowerCase();\r\n        const len = html.length;\r\n        while (position.index < len) {\r\n            const nextTag = html.indexOf('</', position.index);\r\n            if (nextTag === -1) {\r\n                this.scanText();\r\n                break;\r\n            }\r\n            jumpPosition(position, html, nextTag);\r\n            const name = this.scanTag();\r\n            if (safeTagName === name.toLowerCase()) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\n\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\r\nconst specialMiniElements = {\r\n    img: 'image',\r\n    iframe: 'web-view'\r\n};\r\nconst internalCompsList = Object.keys(internalComponents)\r\n    .map(i => i.toLowerCase())\r\n    .join(',');\r\n// https://developers.weixin.qq.com/miniprogram/dev/component\r\nconst isMiniElements = makeMap(internalCompsList, true);\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\r\nconst isInlineElements = makeMap('a,i,abbr,iframe,select,acronym,slot,small,span,bdi,kbd,strong,big,map,sub,sup,br,mark,mark,meter,template,canvas,textarea,cite,object,time,code,output,u,data,picture,tt,datalist,var,dfn,del,q,em,s,embed,samp,b', true);\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\r\nconst isBlockElements = makeMap('address,fieldset,li,article,figcaption,main,aside,figure,nav,blockquote,footer,ol,details,form,p,dialog,h1,h2,h3,h4,h5,h6,pre,dd,header,section,div,hgroup,table,dl,hr,ul,dt', true);\n\nfunction unquote(str) {\r\n    const car = str.charAt(0);\r\n    const end = str.length - 1;\r\n    const isQuoteStart = car === '\"' || car === \"'\";\r\n    if (isQuoteStart && car === str.charAt(end)) {\r\n        return str.slice(1, end);\r\n    }\r\n    return str;\r\n}\n\nconst LEFT_BRACKET = '{';\r\nconst RIGHT_BRACKET = '}';\r\nconst CLASS_SELECTOR = '.';\r\nconst ID_SELECTOR = '#';\r\nconst CHILD_COMBINATOR = '>';\r\nconst GENERAL_SIBLING_COMBINATOR = '~';\r\nconst ADJACENT_SIBLING_COMBINATOR = '+';\r\nclass StyleTagParser {\r\n    constructor() {\r\n        this.styles = [];\r\n    }\r\n    extractStyle(src) {\r\n        const REG_STYLE = /<style\\s?[^>]*>((.|\\n|\\s)+?)<\\/style>/g;\r\n        let html = src;\r\n        // let html = src.replace(/\\n/g, '')\r\n        html = html.replace(REG_STYLE, (_, $1) => {\r\n            const style = $1.trim();\r\n            this.stringToSelector(style);\r\n            return '';\r\n        });\r\n        return html.trim();\r\n    }\r\n    stringToSelector(style) {\r\n        let lb = style.indexOf(LEFT_BRACKET);\r\n        while (lb > -1) {\r\n            const rb = style.indexOf(RIGHT_BRACKET);\r\n            const selectors = style.slice(0, lb).trim();\r\n            let content = style.slice(lb + 1, rb);\r\n            content = content.replace(/:(.*);/g, function (_, $1) {\r\n                const t = $1.trim().replace(/ +/g, '+++');\r\n                return `:${t};`;\r\n            });\r\n            content = content.replace(/ /g, '');\r\n            content = content.replace(/\\+\\+\\+/g, ' ');\r\n            if (!(/;$/.test(content))) {\r\n                content += ';';\r\n            }\r\n            selectors.split(',').forEach(src => {\r\n                const selectorList = this.parseSelector(src);\r\n                this.styles.push({\r\n                    content,\r\n                    selectorList\r\n                });\r\n            });\r\n            style = style.slice(rb + 1);\r\n            lb = style.indexOf(LEFT_BRACKET);\r\n        }\r\n        // console.log('res this.styles: ', this.styles)\r\n    }\r\n    parseSelector(src) {\r\n        const list = src\r\n            .trim()\r\n            .replace(/ *([>~+]) */g, ' $1')\r\n            .replace(/ +/g, ' ')\r\n            .replace(/\\[\\s*([^[\\]=\\s]+)\\s*=\\s*([^[\\]=\\s]+)\\s*\\]/g, '[$1=$2]')\r\n            .split(' ');\r\n        const selectors = list.map(item => {\r\n            const firstChar = item.charAt(0);\r\n            const selector = {\r\n                isChild: firstChar === CHILD_COMBINATOR,\r\n                isGeneralSibling: firstChar === GENERAL_SIBLING_COMBINATOR,\r\n                isAdjacentSibling: firstChar === ADJACENT_SIBLING_COMBINATOR,\r\n                tag: null,\r\n                id: null,\r\n                class: [],\r\n                attrs: []\r\n            };\r\n            item = item.replace(/^[>~+]/, '');\r\n            // 属性选择器\r\n            item = item.replace(/\\[(.+?)\\]/g, function (_, $1) {\r\n                const [key, value] = $1.split('=');\r\n                const all = $1.indexOf('=') === -1;\r\n                const attr = {\r\n                    all,\r\n                    key,\r\n                    value: all ? null : value\r\n                };\r\n                selector.attrs.push(attr);\r\n                return '';\r\n            });\r\n            item = item.replace(/([.#][A-Za-z0-9-_]+)/g, function (_, $1) {\r\n                if ($1[0] === ID_SELECTOR) {\r\n                    // id 选择器\r\n                    selector.id = $1.substr(1);\r\n                }\r\n                else if ($1[0] === CLASS_SELECTOR) {\r\n                    // class 选择器\r\n                    selector.class.push($1.substr(1));\r\n                }\r\n                return '';\r\n            });\r\n            // 标签选择器\r\n            if (item !== '') {\r\n                selector.tag = item;\r\n            }\r\n            return selector;\r\n        });\r\n        return selectors;\r\n    }\r\n    matchStyle(tagName, el, list) {\r\n        const res = sortStyles(this.styles).reduce((str, { content, selectorList }, i) => {\r\n            let idx = list[i];\r\n            let selector = selectorList[idx];\r\n            const nextSelector = selectorList[idx + 1];\r\n            if ((nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isGeneralSibling) || (nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isAdjacentSibling)) {\r\n                selector = nextSelector;\r\n                idx += 1;\r\n                list[i] += 1;\r\n            }\r\n            let isMatch = this.matchCurrent(tagName, el, selector);\r\n            if (isMatch && selector.isGeneralSibling) {\r\n                let prev = getPreviousElement(el);\r\n                while (prev) {\r\n                    if (prev.h5tagName && this.matchCurrent(prev.h5tagName, prev, selectorList[idx - 1])) {\r\n                        isMatch = true;\r\n                        break;\r\n                    }\r\n                    prev = getPreviousElement(prev);\r\n                    isMatch = false;\r\n                }\r\n            }\r\n            if (isMatch && selector.isAdjacentSibling) {\r\n                const prev = getPreviousElement(el);\r\n                if (!prev || !prev.h5tagName) {\r\n                    isMatch = false;\r\n                }\r\n                else {\r\n                    const isSiblingMatch = this.matchCurrent(prev.h5tagName, prev, selectorList[idx - 1]);\r\n                    if (!isSiblingMatch) {\r\n                        isMatch = false;\r\n                    }\r\n                }\r\n            }\r\n            if (isMatch) {\r\n                if (idx === selectorList.length - 1) {\r\n                    return str + content;\r\n                }\r\n                else if (idx < selectorList.length - 1) {\r\n                    list[i] += 1;\r\n                }\r\n            }\r\n            else {\r\n                // 直接子代组合器: >\r\n                if (selector.isChild && idx > 0) {\r\n                    list[i] -= 1;\r\n                    if (this.matchCurrent(tagName, el, selectorList[list[i]])) {\r\n                        list[i] += 1;\r\n                    }\r\n                }\r\n            }\r\n            return str;\r\n        }, '');\r\n        return res;\r\n    }\r\n    matchCurrent(tagName, el, selector) {\r\n        // 标签选择器\r\n        if (selector.tag && selector.tag !== tagName)\r\n            return false;\r\n        // id 选择器\r\n        if (selector.id && selector.id !== el.id)\r\n            return false;\r\n        // class 选择器\r\n        if (selector.class.length) {\r\n            const classList = el.className.split(' ');\r\n            for (let i = 0; i < selector.class.length; i++) {\r\n                const cls = selector.class[i];\r\n                if (classList.indexOf(cls) === -1) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        // 属性选择器\r\n        if (selector.attrs.length) {\r\n            for (let i = 0; i < selector.attrs.length; i++) {\r\n                const { all, key, value } = selector.attrs[i];\r\n                if (all && !el.hasAttribute(key)) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    const attr = el.getAttribute(key);\r\n                    if (attr !== unquote(value || '')) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nfunction getPreviousElement(el) {\r\n    const parent = el.parentElement;\r\n    if (!parent)\r\n        return null;\r\n    const prev = el.previousSibling;\r\n    if (!prev)\r\n        return null;\r\n    if (prev.nodeType === 1 /* ELEMENT_NODE */) {\r\n        return prev;\r\n    }\r\n    else {\r\n        return getPreviousElement(prev);\r\n    }\r\n}\r\n// 根据 css selector 权重排序: 权重大的靠后\r\n// @WARN 不考虑伪类\r\n// https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#specificity_2\r\nfunction sortStyles(styles) {\r\n    return styles.sort((s1, s2) => {\r\n        const hundreds1 = getHundredsWeight(s1.selectorList);\r\n        const hundreds2 = getHundredsWeight(s2.selectorList);\r\n        if (hundreds1 !== hundreds2)\r\n            return hundreds1 - hundreds2;\r\n        const tens1 = getTensWeight(s1.selectorList);\r\n        const tens2 = getTensWeight(s2.selectorList);\r\n        if (tens1 !== tens2)\r\n            return tens1 - tens2;\r\n        const ones1 = getOnesWeight(s1.selectorList);\r\n        const ones2 = getOnesWeight(s2.selectorList);\r\n        return ones1 - ones2;\r\n    });\r\n}\r\nfunction getHundredsWeight(selectors) {\r\n    return selectors.reduce((pre, cur) => pre + (cur.id ? 1 : 0), 0);\r\n}\r\nfunction getTensWeight(selectors) {\r\n    return selectors.reduce((pre, cur) => pre + cur.class.length + cur.attrs.length, 0);\r\n}\r\nfunction getOnesWeight(selectors) {\r\n    return selectors.reduce((pre, cur) => pre + (cur.tag ? 1 : 0), 0);\r\n}\n\nconst closingTagAncestorBreakers = {\r\n    li: ['ul', 'ol', 'menu'],\r\n    dt: ['dl'],\r\n    dd: ['dl'],\r\n    tbody: ['table'],\r\n    thead: ['table'],\r\n    tfoot: ['table'],\r\n    tr: ['table'],\r\n    td: ['table']\r\n};\r\nfunction hasTerminalParent(tagName, stack) {\r\n    const tagParents = closingTagAncestorBreakers[tagName];\r\n    if (tagParents) {\r\n        let currentIndex = stack.length - 1;\r\n        while (currentIndex >= 0) {\r\n            const parentTagName = stack[currentIndex].tagName;\r\n            if (parentTagName === tagName) {\r\n                break;\r\n            }\r\n            if (tagParents && tagParents.includes(parentTagName)) {\r\n                return true;\r\n            }\r\n            currentIndex--;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction getTagName(tag) {\r\n    if (options.html.renderHTMLTag) {\r\n        return tag;\r\n    }\r\n    if (specialMiniElements[tag]) {\r\n        return specialMiniElements[tag];\r\n    }\r\n    else if (isMiniElements(tag)) {\r\n        return tag;\r\n    }\r\n    else if (isBlockElements(tag)) {\r\n        return 'view';\r\n    }\r\n    else if (isInlineElements(tag)) {\r\n        return 'text';\r\n    }\r\n    return 'view';\r\n}\r\nfunction splitEqual(str) {\r\n    const sep = '=';\r\n    const idx = str.indexOf(sep);\r\n    if (idx === -1)\r\n        return [str];\r\n    const key = str.slice(0, idx).trim();\r\n    const value = str.slice(idx + sep.length).trim();\r\n    return [key, value];\r\n}\r\nfunction format(children, document, styleOptions, parent) {\r\n    return children\r\n        .filter(child => {\r\n        // 过滤注释和空文本节点\r\n        if (child.type === 'comment') {\r\n            return false;\r\n        }\r\n        else if (child.type === 'text') {\r\n            return child.content !== '';\r\n        }\r\n        return true;\r\n    })\r\n        .map((child) => {\r\n        // 文本节点\r\n        if (child.type === 'text') {\r\n            let text = document.createTextNode(child.content);\r\n            if (isFunction(options.html.transformText)) {\r\n                text = options.html.transformText(text, child);\r\n            }\r\n            parent === null || parent === void 0 ? void 0 : parent.appendChild(text);\r\n            return text;\r\n        }\r\n        const el = document.createElement(getTagName(child.tagName));\r\n        el.h5tagName = child.tagName;\r\n        parent === null || parent === void 0 ? void 0 : parent.appendChild(el);\r\n        if (!options.html.renderHTMLTag) {\r\n            el.className = `h5-${child.tagName}`;\r\n        }\r\n        for (let i = 0; i < child.attributes.length; i++) {\r\n            const attr = child.attributes[i];\r\n            const [key, value] = splitEqual(attr);\r\n            if (key === 'class') {\r\n                el.className += ' ' + unquote(value);\r\n            }\r\n            else if (key[0] === 'o' && key[1] === 'n') {\r\n                continue;\r\n            }\r\n            else {\r\n                el.setAttribute(key, value == null ? true : unquote(value));\r\n            }\r\n        }\r\n        const { styleTagParser, descendantList } = styleOptions;\r\n        const list = descendantList.slice();\r\n        const style = styleTagParser.matchStyle(child.tagName, el, list);\r\n        el.setAttribute('style', style + el.style.cssText);\r\n        // console.log('style, ', style)\r\n        format(child.children, document, {\r\n            styleTagParser,\r\n            descendantList: list\r\n        }, el);\r\n        if (isFunction(options.html.transformElement)) {\r\n            return options.html.transformElement(el, child);\r\n        }\r\n        return el;\r\n    });\r\n}\r\nfunction parser(html, document) {\r\n    const styleTagParser = new StyleTagParser();\r\n    html = styleTagParser.extractStyle(html);\r\n    const tokens = new Scaner(html).scan();\r\n    const root = { tagName: '', children: [], type: 'element', attributes: [] };\r\n    const state = { tokens, options, cursor: 0, stack: [root] };\r\n    parse(state);\r\n    return format(root.children, document, {\r\n        styleTagParser,\r\n        descendantList: Array(styleTagParser.styles.length).fill(0)\r\n    });\r\n}\r\nfunction parse(state) {\r\n    const { tokens, stack } = state;\r\n    let { cursor } = state;\r\n    const len = tokens.length;\r\n    let nodes = stack[stack.length - 1].children;\r\n    while (cursor < len) {\r\n        const token = tokens[cursor];\r\n        if (token.type !== 'tag-start') {\r\n            // comment or text\r\n            nodes.push(token);\r\n            cursor++;\r\n            continue;\r\n        }\r\n        const tagToken = tokens[++cursor];\r\n        cursor++;\r\n        const tagName = tagToken.content.toLowerCase();\r\n        if (token.close) {\r\n            let index = stack.length;\r\n            let shouldRewind = false;\r\n            while (--index > -1) {\r\n                if (stack[index].tagName === tagName) {\r\n                    shouldRewind = true;\r\n                    break;\r\n                }\r\n            }\r\n            while (cursor < len) {\r\n                const endToken = tokens[cursor];\r\n                if (endToken.type !== 'tag-end')\r\n                    break;\r\n                cursor++;\r\n            }\r\n            if (shouldRewind) {\r\n                stack.splice(index);\r\n                break;\r\n            }\r\n            else {\r\n                continue;\r\n            }\r\n        }\r\n        const isClosingTag = options.html.closingElements.has(tagName);\r\n        let shouldRewindToAutoClose = isClosingTag;\r\n        if (shouldRewindToAutoClose) {\r\n            shouldRewindToAutoClose = !hasTerminalParent(tagName, stack);\r\n        }\r\n        if (shouldRewindToAutoClose) {\r\n            let currentIndex = stack.length - 1;\r\n            while (currentIndex > 0) {\r\n                if (tagName === stack[currentIndex].tagName) {\r\n                    stack.splice(currentIndex);\r\n                    const previousIndex = currentIndex - 1;\r\n                    nodes = stack[previousIndex].children;\r\n                    break;\r\n                }\r\n                currentIndex = currentIndex - 1;\r\n            }\r\n        }\r\n        const attributes = [];\r\n        let attrToken;\r\n        while (cursor < len) {\r\n            attrToken = tokens[cursor];\r\n            if (attrToken.type === 'tag-end')\r\n                break;\r\n            attributes.push(attrToken.content);\r\n            cursor++;\r\n        }\r\n        cursor++;\r\n        const children = [];\r\n        const element = {\r\n            type: 'element',\r\n            tagName: tagToken.content,\r\n            attributes,\r\n            children\r\n        };\r\n        nodes.push(element);\r\n        const hasChildren = !(attrToken.close || options.html.voidElements.has(tagName));\r\n        if (hasChildren) {\r\n            stack.push({ tagName, children });\r\n            const innerState = { tokens, cursor, stack };\r\n            parse(innerState);\r\n            cursor = innerState.cursor;\r\n        }\r\n    }\r\n    state.cursor = cursor;\r\n}\n\noptions.html = {\r\n    skipElements: new Set(['style', 'script']),\r\n    voidElements: new Set([\r\n        '!doctype', 'area', 'base', 'br', 'col', 'command',\r\n        'embed', 'hr', 'img', 'input', 'keygen', 'link',\r\n        'meta', 'param', 'source', 'track', 'wbr'\r\n    ]),\r\n    closingElements: new Set([\r\n        'html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option',\r\n        'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'\r\n    ]),\r\n    renderHTMLTag: false\r\n};\r\nfunction setInnerHTML(element, html, getDoc) {\r\n    while (element.firstChild) {\r\n        element.removeChild(element.firstChild);\r\n    }\r\n    const children = parser(html, getDoc());\r\n    for (let i = 0; i < children.length; i++) {\r\n        element.appendChild(children[i]);\r\n    }\r\n}\n\n/**\r\n * An implementation of `Element.insertAdjacentHTML()`\r\n * to support Vue 3 with a version of or greater than `vue@3.1.2`\r\n */\r\nfunction insertAdjacentHTMLImpl(getDoc, position, html) {\r\n    var _a, _b;\r\n    const parsedNodes = parser(html, getDoc());\r\n    for (let i = 0; i < parsedNodes.length; i++) {\r\n        const n = parsedNodes[i];\r\n        switch (position) {\r\n            case 'beforebegin':\r\n                (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(n, this);\r\n                break;\r\n            case 'afterbegin':\r\n                if (this.hasChildNodes()) {\r\n                    this.insertBefore(n, this.childNodes[0]);\r\n                }\r\n                else {\r\n                    this.appendChild(n);\r\n                }\r\n                break;\r\n            case 'beforeend':\r\n                this.appendChild(n);\r\n                break;\r\n            case 'afterend':\r\n                (_b = this.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(n);\r\n                break;\r\n        }\r\n    }\r\n}\r\nfunction cloneNode(getDoc, isDeep = false) {\r\n    const document = getDoc();\r\n    let newNode;\r\n    if (this.nodeType === 1 /* ELEMENT_NODE */) {\r\n        newNode = document.createElement(this.nodeName);\r\n    }\r\n    else if (this.nodeType === 3 /* TEXT_NODE */) {\r\n        newNode = document.createTextNode('');\r\n    }\r\n    for (const key in this) {\r\n        const value = this[key];\r\n        if ([PROPS, DATASET].includes(key) && typeof value === OBJECT) {\r\n            newNode[key] = Object.assign({}, value);\r\n        }\r\n        else if (key === '_value') {\r\n            newNode[key] = value;\r\n        }\r\n        else if (key === STYLE) {\r\n            newNode.style._value = Object.assign({}, value._value);\r\n            newNode.style._usedStyleProp = new Set(Array.from(value._usedStyleProp));\r\n        }\r\n    }\r\n    if (isDeep) {\r\n        newNode.childNodes = this.childNodes.map(node => node.cloneNode(true));\r\n    }\r\n    return newNode;\r\n}\r\nfunction contains(node) {\r\n    let isContains = false;\r\n    this.childNodes.some(childNode => {\r\n        const { uid } = childNode;\r\n        if (uid === node.uid || uid === node.id || childNode.contains(node)) {\r\n            isContains = true;\r\n            return true;\r\n        }\r\n    });\r\n    return isContains;\r\n}\n\nlet TaroNodeImpl = class TaroNodeImpl {\r\n    constructor(// eslint-disable-next-line @typescript-eslint/indent\r\n    getElement) {\r\n        this.getDoc = () => getElement(ElementNames.Document)();\r\n    }\r\n    bind(ctx) {\r\n        const getDoc = this.getDoc;\r\n        if (ENABLE_INNER_HTML) {\r\n            bindInnerHTML(ctx, getDoc);\r\n            if (ENABLE_ADJACENT_HTML) {\r\n                ctx.insertAdjacentHTML = insertAdjacentHTMLImpl.bind(ctx, getDoc);\r\n            }\r\n        }\r\n        if (ENABLE_CLONE_NODE) {\r\n            ctx.cloneNode = cloneNode.bind(ctx, getDoc);\r\n        }\r\n        if (ENABLE_CONTAINS) {\r\n            ctx.contains = contains.bind(ctx);\r\n        }\r\n    }\r\n};\r\nTaroNodeImpl = __decorate([\r\n    injectable(),\r\n    __param(0, inject(SERVICE_IDENTIFIER.TaroElementFactory)),\r\n    __metadata(\"design:paramtypes\", [Function])\r\n], TaroNodeImpl);\r\nfunction bindInnerHTML(ctx, getDoc) {\r\n    Object.defineProperty(ctx, 'innerHTML', {\r\n        configurable: true,\r\n        enumerable: true,\r\n        set(html) {\r\n            setInnerHTML.call(this, this, html, getDoc);\r\n        },\r\n        get() {\r\n            return '';\r\n        }\r\n    });\r\n}\n\nfunction getBoundingClientRectImpl() {\r\n    if (!options.miniGlobal)\r\n        return Promise.resolve(null);\r\n    return new Promise(resolve => {\r\n        const query = options.miniGlobal.createSelectorQuery();\r\n        query.select(`#${this.uid}`).boundingClientRect(res => {\r\n            resolve(res);\r\n        }).exec();\r\n    });\r\n}\r\nfunction getTemplateContent(ctx) {\r\n    if (ctx.nodeName === 'template') {\r\n        const content = ctx._getElement(ElementNames.Element)(DOCUMENT_FRAGMENT);\r\n        content.childNodes = ctx.childNodes;\r\n        ctx.childNodes = [content];\r\n        content.parentNode = ctx;\r\n        content.childNodes.forEach(nodes => {\r\n            nodes.parentNode = content;\r\n        });\r\n        return content;\r\n    }\r\n}\n\nlet TaroElementImpl = class TaroElementImpl {\r\n    bind(ctx) {\r\n        if (ENABLE_SIZE_APIS) {\r\n            ctx.getBoundingClientRect = getBoundingClientRectImpl.bind(ctx);\r\n        }\r\n        if (ENABLE_TEMPLATE_CONTENT) {\r\n            bindContent(ctx);\r\n        }\r\n    }\r\n};\r\nTaroElementImpl = __decorate([\r\n    injectable()\r\n], TaroElementImpl);\r\nfunction bindContent(ctx) {\r\n    Object.defineProperty(ctx, 'content', {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get() {\r\n            return getTemplateContent(ctx);\r\n        }\r\n    });\r\n}\n\nlet TaroDocument = class TaroDocument extends TaroElement {\r\n    constructor(// eslint-disable-next-line @typescript-eslint/indent\r\n    getText) {\r\n        super();\r\n        this._getText = getText;\r\n        this.nodeType = 9 /* DOCUMENT_NODE */;\r\n        this.nodeName = DOCUMENT_ELEMENT_NAME;\r\n    }\r\n    createElement(type) {\r\n        const getElement = this._getElement;\r\n        if (type === ROOT_STR) {\r\n            return getElement(ElementNames.RootElement)();\r\n        }\r\n        if (controlledComponent.has(type)) {\r\n            return getElement(ElementNames.FormElement)(type);\r\n        }\r\n        return getElement(ElementNames.Element)(type);\r\n    }\r\n    // an ugly fake createElementNS to deal with @vue/runtime-dom's\r\n    // support mounting app to svg container since vue@3.0.8\r\n    createElementNS(_svgNS, type) {\r\n        return this.createElement(type);\r\n    }\r\n    createTextNode(text) {\r\n        return this._getText(text);\r\n    }\r\n    getElementById(id) {\r\n        const el = eventSource.get(id);\r\n        return isUndefined(el) ? null : el;\r\n    }\r\n    querySelector(query) {\r\n        // 为了 Vue3 的乞丐版实现\r\n        if (/^#/.test(query)) {\r\n            return this.getElementById(query.slice(1));\r\n        }\r\n        return null;\r\n    }\r\n    querySelectorAll() {\r\n        // fake hack\r\n        return [];\r\n    }\r\n    // @TODO: @PERF: 在 hydrate 移除掉空的 node\r\n    createComment() {\r\n        const textnode = this._getText('');\r\n        textnode.nodeName = COMMENT;\r\n        return textnode;\r\n    }\r\n};\r\nTaroDocument = __decorate([\r\n    injectable(),\r\n    __param(0, inject(SID_TARO_TEXT_FACTORY)),\r\n    __metadata(\"design:paramtypes\", [Function])\r\n], TaroDocument);\n\n/**\r\n * 支持冒泡的事件, 除 支付宝小程序外，其余的可冒泡事件都和微信保持一致\r\n * 详见 见 https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html\r\n */\r\nconst BUBBLE_EVENTS = new Set([\r\n    'touchstart',\r\n    'touchmove',\r\n    'touchcancel',\r\n    'touchend',\r\n    'touchforcechange',\r\n    'tap',\r\n    'longpress',\r\n    'longtap',\r\n    'transitionend',\r\n    'animationstart',\r\n    'animationiteration',\r\n    'animationend'\r\n]);\n\nconst defaultMiniLifecycle = {\r\n    app: [\r\n        'onLaunch',\r\n        'onShow',\r\n        'onHide'\r\n    ],\r\n    page: [\r\n        'onLoad',\r\n        'onUnload',\r\n        'onReady',\r\n        'onShow',\r\n        'onHide',\r\n        [\r\n            'onPullDownRefresh',\r\n            'onReachBottom',\r\n            'onPageScroll',\r\n            'onResize',\r\n            'onTabItemTap',\r\n            'onTitleClick',\r\n            'onOptionMenuClick',\r\n            'onPopMenuClick',\r\n            'onPullIntercept',\r\n            'onAddToFavorites'\r\n        ]\r\n    ]\r\n};\r\nconst getMiniLifecycle = function (defaultConfig) {\r\n    return defaultConfig;\r\n};\r\nconst getLifecycle = function (instance, lifecycle) {\r\n    return instance[lifecycle];\r\n};\r\nconst getPathIndex = function (indexOfNode) {\r\n    return `[${indexOfNode}]`;\r\n};\r\nconst getEventCenter = function (Events) {\r\n    return new Events();\r\n};\r\nconst isBubbleEvents = function (eventName) {\r\n    return BUBBLE_EVENTS.has(eventName);\r\n};\r\nconst getSpecialNodes = function () {\r\n    return ['view', 'text', 'image'];\r\n};\r\nconst DefaultHooksContainer = new ContainerModule(bind => {\r\n    function bindFunction(sid, target) {\r\n        return bind(sid).toFunction(target);\r\n    }\r\n    bindFunction(SID_GET_MINI_LIFECYCLE, getMiniLifecycle);\r\n    bindFunction(SID_GET_LIFECYCLE, getLifecycle);\r\n    bindFunction(SID_GET_PATH_INDEX, getPathIndex);\r\n    bindFunction(SID_GET_EVENT_CENTER, getEventCenter);\r\n    bindFunction(SID_IS_BUBBLE_EVENTS, isBubbleEvents);\r\n    bindFunction(SID_GET_SPECIAL_NODES, getSpecialNodes);\r\n});\n\nlet Hooks = class Hooks {\r\n    getMiniLifecycleImpl() {\r\n        return this.getMiniLifecycle(defaultMiniLifecycle);\r\n    }\r\n    modifyMpEvent(e) {\r\n        var _a;\r\n        (_a = this.modifyMpEventImpls) === null || _a === void 0 ? void 0 : _a.forEach(fn => {\r\n            try {\r\n                // 有些小程序的事件对象的某些属性只读\r\n                fn(e);\r\n            }\r\n            catch (error) {\r\n                console.warn('[Taro modifyMpEvent hook Error]: ', error);\r\n            }\r\n        });\r\n    }\r\n    modifyTaroEvent(e, element) {\r\n        var _a;\r\n        (_a = this.modifyTaroEventImpls) === null || _a === void 0 ? void 0 : _a.forEach(fn => fn(e, element));\r\n    }\r\n    modifyDispatchEvent(e, element) {\r\n        var _a;\r\n        (_a = this.modifyDispatchEventImpls) === null || _a === void 0 ? void 0 : _a.forEach(fn => fn(e, element));\r\n    }\r\n    initNativeApi(taro) {\r\n        var _a;\r\n        (_a = this.initNativeApiImpls) === null || _a === void 0 ? void 0 : _a.forEach(fn => fn(taro));\r\n    }\r\n    patchElement(element) {\r\n        var _a;\r\n        (_a = this.patchElementImpls) === null || _a === void 0 ? void 0 : _a.forEach(fn => fn(element));\r\n    }\r\n};\r\n__decorate([\r\n    inject(SID_GET_MINI_LIFECYCLE),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"getMiniLifecycle\", void 0);\r\n__decorate([\r\n    inject(SID_GET_LIFECYCLE),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"getLifecycle\", void 0);\r\n__decorate([\r\n    inject(SID_GET_PATH_INDEX),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"getPathIndex\", void 0);\r\n__decorate([\r\n    inject(SID_GET_EVENT_CENTER),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"getEventCenter\", void 0);\r\n__decorate([\r\n    inject(SID_IS_BUBBLE_EVENTS),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"isBubbleEvents\", void 0);\r\n__decorate([\r\n    inject(SID_GET_SPECIAL_NODES),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"getSpecialNodes\", void 0);\r\n__decorate([\r\n    inject(SID_ON_REMOVE_ATTRIBUTE),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"onRemoveAttribute\", void 0);\r\n__decorate([\r\n    inject(SID_BATCHED_EVENT_UPDATES),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"batchedEventUpdates\", void 0);\r\n__decorate([\r\n    inject(SID_MERGE_PAGE_INSTANCE),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"mergePageInstance\", void 0);\r\n__decorate([\r\n    inject(SID_MODIFY_PAGE_OBJECT),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"modifyPageObject\", void 0);\r\n__decorate([\r\n    inject(SID_CREATE_PULLDOWN_COMPONENT),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"createPullDownComponent\", void 0);\r\n__decorate([\r\n    inject(SID_GET_DOM_NODE),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"getDOMNode\", void 0);\r\n__decorate([\r\n    inject(SID_MODIFY_HYDRATE_DATA),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"modifyHydrateData\", void 0);\r\n__decorate([\r\n    inject(SID_MODIFY_SET_ATTR_PAYLOAD),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"modifySetAttrPayload\", void 0);\r\n__decorate([\r\n    inject(SID_MODIFY_RM_ATTR_PAYLOAD),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"modifyRmAttrPayload\", void 0);\r\n__decorate([\r\n    inject(SID_ON_ADD_EVENT),\r\n    optional(),\r\n    __metadata(\"design:type\", Function)\r\n], Hooks.prototype, \"onAddEvent\", void 0);\r\n__decorate([\r\n    multiInject(SID_MODIFY_MP_EVENT),\r\n    optional(),\r\n    __metadata(\"design:type\", Array)\r\n], Hooks.prototype, \"modifyMpEventImpls\", void 0);\r\n__decorate([\r\n    multiInject(SID_MODIFY_TARO_EVENT),\r\n    optional(),\r\n    __metadata(\"design:type\", Array)\r\n], Hooks.prototype, \"modifyTaroEventImpls\", void 0);\r\n__decorate([\r\n    multiInject(SID_MODIFY_DISPATCH_EVENT),\r\n    optional(),\r\n    __metadata(\"design:type\", Array)\r\n], Hooks.prototype, \"modifyDispatchEventImpls\", void 0);\r\n__decorate([\r\n    multiInject(SID_INIT_NATIVE_API),\r\n    optional(),\r\n    __metadata(\"design:type\", Array)\r\n], Hooks.prototype, \"initNativeApiImpls\", void 0);\r\n__decorate([\r\n    multiInject(SID_PATCH_ELEMENT),\r\n    optional(),\r\n    __metadata(\"design:type\", Array)\r\n], Hooks.prototype, \"patchElementImpls\", void 0);\r\nHooks = __decorate([\r\n    injectable()\r\n], Hooks);\n\nfunction processPluginHooks(container) {\r\n    const keys = Object.keys(defaultReconciler);\r\n    keys.forEach(key => {\r\n        if (key in SERVICE_IDENTIFIER) {\r\n            // is hooks\r\n            const identifier = SERVICE_IDENTIFIER[key];\r\n            const fn = defaultReconciler[key];\r\n            if (isArray(fn)) {\r\n                // is multi\r\n                fn.forEach(item => container.bind(identifier).toFunction(item));\r\n            }\r\n            else {\r\n                if (container.isBound(identifier)) {\r\n                    // 之前有绑定过，需要重新绑定以覆盖前者\r\n                    container.rebind(identifier).toFunction(fn);\r\n                }\r\n                else {\r\n                    container.bind(identifier).toFunction(fn);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\n\nconst container = new Container();\r\nfunction bind(sid, target, options = {}) {\r\n    let res = container.bind(sid).to(target);\r\n    if (options.single) {\r\n        res = res.inSingletonScope();\r\n    }\r\n    if (options.name) {\r\n        res = res.whenTargetNamed(options.name);\r\n    }\r\n    return res;\r\n}\r\nif (process.env.TARO_ENV !== 'h5') {\r\n    bind(SID_TARO_TEXT, TaroText);\r\n    bind(SID_TARO_ELEMENT, TaroElement, { name: ElementNames.Element });\r\n    bind(SID_TARO_ELEMENT, TaroRootElement, { name: ElementNames.RootElement });\r\n    bind(SID_TARO_ELEMENT, FormElement, { name: ElementNames.FormElement });\r\n    bind(SID_TARO_ELEMENT, TaroDocument, { name: ElementNames.Document, single: true });\r\n    bind(SID_TARO_NODE_IMPL, TaroNodeImpl, { single: true });\r\n    bind(SID_TARO_ELEMENT_IMPL, TaroElementImpl, { single: true });\r\n    container.bind(SID_TARO_ELEMENT_FACTORY).toFactory((context) => {\r\n        return (named) => (nodeName) => {\r\n            const el = context.container.getNamed(SID_TARO_ELEMENT, named);\r\n            if (nodeName) {\r\n                el.nodeName = nodeName;\r\n            }\r\n            el.tagName = el.nodeName.toUpperCase();\r\n            return el;\r\n        };\r\n    });\r\n    container.bind(SID_TARO_TEXT_FACTORY).toFactory((context) => {\r\n        return (text) => {\r\n            const textNode = context.container.get(SID_TARO_TEXT);\r\n            textNode._value = text;\r\n            return textNode;\r\n        };\r\n    });\r\n}\r\nbind(SID_HOOKS, Hooks, { single: true });\r\ncontainer.load(DefaultHooksContainer);\r\nprocessPluginHooks(container);\r\nstore.container = container;\n\nfunction createDocument() {\r\n    /**\r\n     * <document>\r\n     *   <html>\r\n     *     <head></head>\r\n     *     <body>\r\n     *       <container>\r\n     *         <app id=\"app\" />\r\n     *       </container>\r\n     *     </body>\r\n     *   </html>\r\n     * </document>\r\n     */\r\n    const getElement = container.get(SERVICE_IDENTIFIER.TaroElementFactory);\r\n    const doc = getElement(ElementNames.Document)();\r\n    const documentCreateElement = doc.createElement.bind(doc);\r\n    const html = documentCreateElement(HTML);\r\n    const head = documentCreateElement(HEAD);\r\n    const body = documentCreateElement(BODY);\r\n    const app = documentCreateElement(APP);\r\n    app.id = APP;\r\n    const container$1 = documentCreateElement(CONTAINER); // 多包一层主要为了兼容 vue\r\n    doc.appendChild(html);\r\n    html.appendChild(head);\r\n    html.appendChild(body);\r\n    body.appendChild(container$1);\r\n    container$1.appendChild(app);\r\n    doc.documentElement = html;\r\n    doc.head = head;\r\n    doc.body = body;\r\n    doc.createEvent = createEvent;\r\n    return doc;\r\n}\r\nconst document$1 = process.env.TARO_ENV === 'h5'\r\n    ? doc\r\n    : createDocument();\n\nconst machine = 'Macintosh';\r\nconst arch = 'Intel Mac OS X 10_14_5';\r\nconst engine = 'AppleWebKit/534.36 (KHTML, like Gecko) NodeJS/v4.1.0 Chrome/76.0.3809.132 Safari/534.36';\r\nconst msg = '(' + machine + '; ' + arch + ') ' + engine;\r\nconst navigator = process.env.TARO_ENV === 'h5' ? win.navigator : {\r\n    appCodeName: 'Mozilla',\r\n    appName: 'Netscape',\r\n    appVersion: '5.0 ' + msg,\r\n    cookieEnabled: true,\r\n    mimeTypes: [],\r\n    onLine: true,\r\n    platform: 'MacIntel',\r\n    plugins: [],\r\n    product: 'Taro',\r\n    productSub: '20030107',\r\n    userAgent: 'Mozilla/5.0 ' + msg,\r\n    vendor: 'Joyent',\r\n    vendorSub: ''\r\n};\n\n// https://github.com/myrne/performance-now\r\nlet now;\r\n(function () {\r\n    let loadTime;\r\n    if ((typeof performance !== 'undefined' && performance !== null) && performance.now) {\r\n        now = function () {\r\n            return performance.now();\r\n        };\r\n    }\r\n    else if (Date.now) {\r\n        now = function () {\r\n            return Date.now() - loadTime;\r\n        };\r\n        loadTime = Date.now();\r\n    }\r\n    else {\r\n        now = function () {\r\n            return new Date().getTime() - loadTime;\r\n        };\r\n        loadTime = new Date().getTime();\r\n    }\r\n})();\r\nlet lastTime = 0;\r\n// https://gist.github.com/paulirish/1579671\r\n// https://gist.github.com/jalbam/5fe05443270fa6d8136238ec72accbc0\r\nconst raf = typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame !== null ? requestAnimationFrame : function (callback) {\r\n    const _now = now();\r\n    const nextTime = Math.max(lastTime + 16, _now); // First time will execute it immediately but barely noticeable and performance is gained.\r\n    return setTimeout(function () { callback(lastTime = nextTime); }, nextTime - _now);\r\n};\r\nconst caf = typeof cancelAnimationFrame !== 'undefined' && cancelAnimationFrame !== null\r\n    ? cancelAnimationFrame\r\n    : function (seed) {\r\n        // fix https://github.com/NervJS/taro/issues/7749\r\n        clearTimeout(seed);\r\n    };\n\nfunction getComputedStyle(element) {\r\n    return element.style;\r\n}\n\nconst window$1 = process.env.TARO_ENV === 'h5' ? win : {\r\n    navigator,\r\n    document: document$1\r\n};\r\nif (process.env.TARO_ENV && process.env.TARO_ENV !== 'h5') {\r\n    const globalProperties = [\r\n        ...Object.getOwnPropertyNames(global || win),\r\n        ...Object.getOwnPropertySymbols(global || win)\r\n    ];\r\n    globalProperties.forEach(property => {\r\n        if (property === 'atob')\r\n            return;\r\n        if (!Object.prototype.hasOwnProperty.call(window$1, property)) {\r\n            window$1[property] = global[property];\r\n        }\r\n    });\r\n    window$1.requestAnimationFrame = raf;\r\n    window$1.cancelAnimationFrame = caf;\r\n    window$1.getComputedStyle = getComputedStyle;\r\n    window$1.addEventListener = noop;\r\n    window$1.removeEventListener = noop;\r\n    if (!(DATE in window$1)) {\r\n        window$1.Date = Date;\r\n    }\r\n    window$1.setTimeout = function (...args) {\r\n        return setTimeout(...args);\r\n    };\r\n    window$1.clearTimeout = function (...args) {\r\n        return clearTimeout(...args);\r\n    };\r\n    document$1.defaultView = window$1;\r\n}\n\nconst Current = {\r\n    app: null,\r\n    router: null,\r\n    page: null\r\n};\r\nconst getCurrentInstance = () => Current;\n\nclass Events {\r\n    constructor(opts) {\r\n        var _a;\r\n        this.callbacks = (_a = opts === null || opts === void 0 ? void 0 : opts.callbacks) !== null && _a !== void 0 ? _a : {};\r\n    }\r\n    on(eventName, callback, context) {\r\n        let event, node, tail, list;\r\n        if (!callback) {\r\n            return this;\r\n        }\r\n        eventName = eventName.split(Events.eventSplitter);\r\n        this.callbacks || (this.callbacks = {});\r\n        const calls = this.callbacks;\r\n        while ((event = eventName.shift())) {\r\n            list = calls[event];\r\n            node = list ? list.tail : {};\r\n            node.next = tail = {};\r\n            node.context = context;\r\n            node.callback = callback;\r\n            calls[event] = {\r\n                tail,\r\n                next: list ? list.next : node\r\n            };\r\n        }\r\n        return this;\r\n    }\r\n    once(events, callback, context) {\r\n        const wrapper = (...args) => {\r\n            callback.apply(this, args);\r\n            this.off(events, wrapper, context);\r\n        };\r\n        this.on(events, wrapper, context);\r\n        return this;\r\n    }\r\n    off(events, callback, context) {\r\n        let event, calls, node, tail, cb, ctx;\r\n        if (!(calls = this.callbacks)) {\r\n            return this;\r\n        }\r\n        if (!(events || callback || context)) {\r\n            delete this.callbacks;\r\n            return this;\r\n        }\r\n        events = events ? events.split(Events.eventSplitter) : Object.keys(calls);\r\n        while ((event = events.shift())) {\r\n            node = calls[event];\r\n            delete calls[event];\r\n            if (!node || !(callback || context)) {\r\n                continue;\r\n            }\r\n            tail = node.tail;\r\n            while ((node = node.next) !== tail) {\r\n                cb = node.callback;\r\n                ctx = node.context;\r\n                if ((callback && cb !== callback) || (context && ctx !== context)) {\r\n                    this.on(event, cb, ctx);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    trigger(events) {\r\n        let event, node, calls, tail;\r\n        if (!(calls = this.callbacks)) {\r\n            return this;\r\n        }\r\n        events = events.split(Events.eventSplitter);\r\n        const rest = [].slice.call(arguments, 1);\r\n        while ((event = events.shift())) {\r\n            if ((node = calls[event])) {\r\n                tail = node.tail;\r\n                while ((node = node.next) !== tail) {\r\n                    node.callback.apply(node.context || this, rest);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n}\r\nEvents.eventSplitter = /\\s+/;\r\nconst eventCenter = getHooks().getEventCenter(Events);\r\ncontainer.bind(SID_EVENT_CENTER).toConstantValue(eventCenter);\n\n/* eslint-disable dot-notation */\r\nconst instances = new Map();\r\nconst pageId = incrementId();\r\nfunction injectPageInstance(inst, id) {\r\n    var _a, _b;\r\n    (_b = (_a = getHooks()).mergePageInstance) === null || _b === void 0 ? void 0 : _b.call(_a, instances.get(id), inst);\r\n    instances.set(id, inst);\r\n}\r\nfunction getPageInstance(id) {\r\n    return instances.get(id);\r\n}\r\nfunction addLeadingSlash(path) {\r\n    if (path == null) {\r\n        return '';\r\n    }\r\n    return path.charAt(0) === '/' ? path : '/' + path;\r\n}\r\nfunction safeExecute(path, lifecycle, ...args) {\r\n    const instance = instances.get(path);\r\n    if (instance == null) {\r\n        return;\r\n    }\r\n    const func = getHooks().getLifecycle(instance, lifecycle);\r\n    if (isArray(func)) {\r\n        const res = func.map(fn => fn.apply(instance, args));\r\n        return res[0];\r\n    }\r\n    if (!isFunction(func)) {\r\n        return;\r\n    }\r\n    return func.apply(instance, args);\r\n}\r\nfunction stringify(obj) {\r\n    if (obj == null) {\r\n        return '';\r\n    }\r\n    const path = Object.keys(obj).map((key) => {\r\n        return key + '=' + obj[key];\r\n    }).join('&');\r\n    return path === '' ? path : '?' + path;\r\n}\r\nfunction getPath(id, options) {\r\n    const idx = id.indexOf('?');\r\n    return `${idx > -1 ? id.substring(0, idx) : id}${stringify(process.env.TARO_ENV === 'h5' ? { stamp: (options === null || options === void 0 ? void 0 : options.stamp) || '' } : options)}`;\r\n}\r\nfunction getOnReadyEventKey(path) {\r\n    return path + '.' + ON_READY;\r\n}\r\nfunction getOnShowEventKey(path) {\r\n    return path + '.' + ON_SHOW;\r\n}\r\nfunction getOnHideEventKey(path) {\r\n    return path + '.' + ON_HIDE;\r\n}\r\nfunction createPageConfig(component, pageName, data, pageConfig) {\r\n    var _a, _b, _c;\r\n    // 小程序 Page 构造器是一个傲娇小公主，不能把复杂的对象挂载到参数上\r\n    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${pageId()}`;\r\n    const hooks = getHooks();\r\n    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES] = hooks.getMiniLifecycleImpl().page;\r\n    let pageElement = null;\r\n    let unmounting = false;\r\n    let prepareMountList = [];\r\n    function setCurrentRouter(page) {\r\n        const router = process.env.TARO_ENV === 'h5' ? page.$taroPath : page.route || page.__route__ || page.$taroPath;\r\n        Current.router = {\r\n            params: page.$taroParams,\r\n            path: addLeadingSlash(router),\r\n            onReady: getOnReadyEventKey(id),\r\n            onShow: getOnShowEventKey(id),\r\n            onHide: getOnHideEventKey(id)\r\n        };\r\n    }\r\n    let loadResolver;\r\n    let hasLoaded;\r\n    const config = {\r\n        [ONLOAD](options = {}, cb) {\r\n            hasLoaded = new Promise(resolve => { loadResolver = resolve; });\r\n            perf.start(PAGE_INIT);\r\n            Current.page = this;\r\n            this.config = pageConfig || {};\r\n            options.$taroTimestamp = Date.now();\r\n            // this.$taroPath 是页面唯一标识，不可变，因此页面参数 options 也不可变\r\n            this.$taroPath = getPath(id, options);\r\n            const $taroPath = this.$taroPath;\r\n            if (process.env.TARO_ENV === 'h5') {\r\n                config.path = this.$taroPath;\r\n            }\r\n            // this.$taroParams 作为暴露给开发者的页面参数对象，可以被随意修改\r\n            if (this.$taroParams == null) {\r\n                this.$taroParams = Object.assign({}, options);\r\n            }\r\n            setCurrentRouter(this);\r\n            const mount = () => {\r\n                Current.app.mount(component, $taroPath, () => {\r\n                    pageElement = document$1.getElementById($taroPath);\r\n                    ensure(pageElement !== null, '没有找到页面实例。');\r\n                    safeExecute($taroPath, ON_LOAD, this.$taroParams);\r\n                    loadResolver();\r\n                    if (process.env.TARO_ENV !== 'h5') {\r\n                        pageElement.ctx = this;\r\n                        pageElement.performUpdate(true, cb);\r\n                    }\r\n                    else {\r\n                        isFunction(cb) && cb();\r\n                    }\r\n                });\r\n            };\r\n            if (unmounting) {\r\n                prepareMountList.push(mount);\r\n            }\r\n            else {\r\n                mount();\r\n            }\r\n        },\r\n        [ONUNLOAD]() {\r\n            const $taroPath = this.$taroPath;\r\n            unmounting = true;\r\n            Current.app.unmount($taroPath, () => {\r\n                unmounting = false;\r\n                instances.delete($taroPath);\r\n                if (pageElement) {\r\n                    pageElement.ctx = null;\r\n                    pageElement = null;\r\n                }\r\n                if (prepareMountList.length) {\r\n                    prepareMountList.forEach(fn => fn());\r\n                    prepareMountList = [];\r\n                }\r\n            });\r\n        },\r\n        [ONREADY]() {\r\n            // 触发生命周期\r\n            safeExecute(this.$taroPath, ON_READY);\r\n            // 通过事件触发子组件的生命周期\r\n            raf(() => eventCenter.trigger(getOnReadyEventKey(id)));\r\n            this.onReady.called = true;\r\n        },\r\n        [ONSHOW](options = {}) {\r\n            hasLoaded.then(() => {\r\n                // 设置 Current 的 page 和 router\r\n                Current.page = this;\r\n                setCurrentRouter(this);\r\n                // 触发生命周期\r\n                safeExecute(this.$taroPath, ON_SHOW, options);\r\n                // 通过事件触发子组件的生命周期\r\n                raf(() => eventCenter.trigger(getOnShowEventKey(id)));\r\n            });\r\n        },\r\n        [ONHIDE]() {\r\n            // 设置 Current 的 page 和 router\r\n            if (Current.page === this) {\r\n                Current.page = null;\r\n                Current.router = null;\r\n            }\r\n            // 触发生命周期\r\n            safeExecute(this.$taroPath, ON_HIDE);\r\n            // 通过事件触发子组件的生命周期\r\n            eventCenter.trigger(getOnHideEventKey(id));\r\n        }\r\n    };\r\n    LIFECYCLES.forEach((lifecycle) => {\r\n        config[lifecycle] = function () {\r\n            return safeExecute(this.$taroPath, lifecycle, ...arguments);\r\n        };\r\n    });\r\n    // onShareAppMessage 和 onShareTimeline 一样，会影响小程序右上方按钮的选项，因此不能默认注册。\r\n    if (component.onShareAppMessage ||\r\n        ((_a = component.prototype) === null || _a === void 0 ? void 0 : _a.onShareAppMessage) ||\r\n        component.enableShareAppMessage) {\r\n        config.onShareAppMessage = function (options) {\r\n            const target = options === null || options === void 0 ? void 0 : options.target;\r\n            if (target) {\r\n                const id = target.id;\r\n                const element = document$1.getElementById(id);\r\n                if (element) {\r\n                    target.dataset = element.dataset;\r\n                }\r\n            }\r\n            return safeExecute(this.$taroPath, 'onShareAppMessage', options);\r\n        };\r\n    }\r\n    if (component.onShareTimeline ||\r\n        ((_b = component.prototype) === null || _b === void 0 ? void 0 : _b.onShareTimeline) ||\r\n        component.enableShareTimeline) {\r\n        config.onShareTimeline = function () {\r\n            return safeExecute(this.$taroPath, 'onShareTimeline');\r\n        };\r\n    }\r\n    config.eh = eventHandler;\r\n    if (!isUndefined(data)) {\r\n        config.data = data;\r\n    }\r\n    (_c = hooks.modifyPageObject) === null || _c === void 0 ? void 0 : _c.call(hooks, config);\r\n    return config;\r\n}\r\nfunction createComponentConfig(component, componentName, data) {\r\n    const id = componentName !== null && componentName !== void 0 ? componentName : `taro_component_${pageId()}`;\r\n    let componentElement = null;\r\n    const config = {\r\n        attached() {\r\n            var _a;\r\n            perf.start(PAGE_INIT);\r\n            const path = getPath(id, { id: ((_a = this.getPageId) === null || _a === void 0 ? void 0 : _a.call(this)) || pageId() });\r\n            Current.app.mount(component, path, () => {\r\n                componentElement = document$1.getElementById(path);\r\n                ensure(componentElement !== null, '没有找到组件实例。');\r\n                this.$taroInstances = instances.get(path);\r\n                safeExecute(path, ON_LOAD);\r\n                if (process.env.TARO_ENV !== 'h5') {\r\n                    componentElement.ctx = this;\r\n                    componentElement.performUpdate(true);\r\n                }\r\n            });\r\n        },\r\n        detached() {\r\n            const path = getPath(id, { id: this.getPageId() });\r\n            Current.app.unmount(path, () => {\r\n                instances.delete(path);\r\n                if (componentElement) {\r\n                    componentElement.ctx = null;\r\n                }\r\n            });\r\n        },\r\n        methods: {\r\n            eh: eventHandler\r\n        }\r\n    };\r\n    if (!isUndefined(data)) {\r\n        config.data = data;\r\n    }\r\n    [OPTIONS, EXTERNAL_CLASSES, BEHAVIORS].forEach(key => {\r\n        var _a;\r\n        config[key] = (_a = component[key]) !== null && _a !== void 0 ? _a : EMPTY_OBJ;\r\n    });\r\n    return config;\r\n}\r\nfunction createRecursiveComponentConfig(componentName) {\r\n    const isCustomWrapper = componentName === CUSTOM_WRAPPER;\r\n    const lifeCycles = isCustomWrapper\r\n        ? {\r\n            attached() {\r\n                var _a;\r\n                const componentId = (_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid;\r\n                if (isString(componentId)) {\r\n                    customWrapperCache.set(componentId, this);\r\n                }\r\n            },\r\n            detached() {\r\n                var _a;\r\n                const componentId = (_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid;\r\n                if (isString(componentId)) {\r\n                    customWrapperCache.delete(componentId);\r\n                }\r\n            }\r\n        }\r\n        : EMPTY_OBJ;\r\n    return Object.assign({ properties: {\r\n            i: {\r\n                type: Object,\r\n                value: {\r\n                    [\"nn\" /* NodeName */]: VIEW\r\n                }\r\n            },\r\n            l: {\r\n                type: String,\r\n                value: ''\r\n            }\r\n        }, options: {\r\n            addGlobalClass: true,\r\n            virtualHost: !isCustomWrapper\r\n        }, methods: {\r\n            eh: eventHandler\r\n        } }, lifeCycles);\r\n}\n\nfunction removeLeadingSlash(path) {\r\n    if (path == null) {\r\n        return '';\r\n    }\r\n    return path.charAt(0) === '/' ? path.slice(1) : path;\r\n}\r\nconst nextTick = (cb, ctx) => {\r\n    var _a, _b, _c;\r\n    const router = Current.router;\r\n    const timerFunc = () => {\r\n        setTimeout(function () {\r\n            ctx ? cb.call(ctx) : cb();\r\n        }, 1);\r\n    };\r\n    if (router !== null) {\r\n        let pageElement = null;\r\n        const path = getPath(removeLeadingSlash(router.path), router.params);\r\n        pageElement = document$1.getElementById(path);\r\n        if (pageElement === null || pageElement === void 0 ? void 0 : pageElement.pendingUpdate) {\r\n            if (process.env.TARO_ENV === 'h5') {\r\n                // eslint-disable-next-line dot-notation\r\n                (_c = (_b = (_a = pageElement.firstChild) === null || _a === void 0 ? void 0 : _a['componentOnReady']) === null || _b === void 0 ? void 0 : _b.call(_a).then(() => {\r\n                    timerFunc();\r\n                })) !== null && _c !== void 0 ? _c : timerFunc();\r\n            }\r\n            else {\r\n                pageElement.enqueueUpdateCallback(cb, ctx);\r\n            }\r\n        }\r\n        else {\r\n            timerFunc();\r\n        }\r\n    }\r\n    else {\r\n        timerFunc();\r\n    }\r\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'Current', { enumerable: true, configurable: true, get: function() { return Current; } });Object.defineProperty(exports, 'ElementNames', { enumerable: true, configurable: true, get: function() { return ElementNames; } });Object.defineProperty(exports, 'Events', { enumerable: true, configurable: true, get: function() { return Events; } });Object.defineProperty(exports, 'FormElement', { enumerable: true, configurable: true, get: function() { return FormElement; } });Object.defineProperty(exports, 'MutationObserver', { enumerable: true, configurable: true, get: function() { return MutationObserver; } });Object.defineProperty(exports, 'SERVICE_IDENTIFIER', { enumerable: true, configurable: true, get: function() { return SERVICE_IDENTIFIER; } });Object.defineProperty(exports, 'SVGElement', { enumerable: true, configurable: true, get: function() { return SVGElement; } });Object.defineProperty(exports, 'Style', { enumerable: true, configurable: true, get: function() { return Style; } });Object.defineProperty(exports, 'TaroElement', { enumerable: true, configurable: true, get: function() { return TaroElement; } });Object.defineProperty(exports, 'TaroEvent', { enumerable: true, configurable: true, get: function() { return TaroEvent; } });Object.defineProperty(exports, 'TaroNode', { enumerable: true, configurable: true, get: function() { return TaroNode; } });Object.defineProperty(exports, 'TaroRootElement', { enumerable: true, configurable: true, get: function() { return TaroRootElement; } });Object.defineProperty(exports, 'TaroText', { enumerable: true, configurable: true, get: function() { return TaroText; } });Object.defineProperty(exports, 'addLeadingSlash', { enumerable: true, configurable: true, get: function() { return addLeadingSlash; } });Object.defineProperty(exports, 'cancelAnimationFrame', { enumerable: true, configurable: true, get: function() { return caf; } });Object.defineProperty(exports, 'container', { enumerable: true, configurable: true, get: function() { return container; } });Object.defineProperty(exports, 'createComponentConfig', { enumerable: true, configurable: true, get: function() { return createComponentConfig; } });Object.defineProperty(exports, 'createDocument', { enumerable: true, configurable: true, get: function() { return createDocument; } });Object.defineProperty(exports, 'createEvent', { enumerable: true, configurable: true, get: function() { return createEvent; } });Object.defineProperty(exports, 'createPageConfig', { enumerable: true, configurable: true, get: function() { return createPageConfig; } });Object.defineProperty(exports, 'createRecursiveComponentConfig', { enumerable: true, configurable: true, get: function() { return createRecursiveComponentConfig; } });Object.defineProperty(exports, 'document', { enumerable: true, configurable: true, get: function() { return document$1; } });Object.defineProperty(exports, 'eventCenter', { enumerable: true, configurable: true, get: function() { return eventCenter; } });Object.defineProperty(exports, 'eventHandler', { enumerable: true, configurable: true, get: function() { return eventHandler; } });Object.defineProperty(exports, 'eventSource', { enumerable: true, configurable: true, get: function() { return eventSource; } });Object.defineProperty(exports, 'getComputedStyle', { enumerable: true, configurable: true, get: function() { return getComputedStyle; } });Object.defineProperty(exports, 'getCurrentInstance', { enumerable: true, configurable: true, get: function() { return getCurrentInstance; } });Object.defineProperty(exports, 'getPageInstance', { enumerable: true, configurable: true, get: function() { return getPageInstance; } });Object.defineProperty(exports, 'hydrate', { enumerable: true, configurable: true, get: function() { return hydrate; } });Object.defineProperty(exports, 'incrementId', { enumerable: true, configurable: true, get: function() { return incrementId; } });Object.defineProperty(exports, 'injectPageInstance', { enumerable: true, configurable: true, get: function() { return injectPageInstance; } });Object.defineProperty(exports, 'navigator', { enumerable: true, configurable: true, get: function() { return navigator; } });Object.defineProperty(exports, 'nextTick', { enumerable: true, configurable: true, get: function() { return nextTick; } });Object.defineProperty(exports, 'now', { enumerable: true, configurable: true, get: function() { return now; } });Object.defineProperty(exports, 'options', { enumerable: true, configurable: true, get: function() { return options; } });Object.defineProperty(exports, 'processPluginHooks', { enumerable: true, configurable: true, get: function() { return processPluginHooks; } });Object.defineProperty(exports, 'requestAnimationFrame', { enumerable: true, configurable: true, get: function() { return raf; } });Object.defineProperty(exports, 'safeExecute', { enumerable: true, configurable: true, get: function() { return safeExecute; } });Object.defineProperty(exports, 'stringify', { enumerable: true, configurable: true, get: function() { return stringify; } });Object.defineProperty(exports, 'window', { enumerable: true, configurable: true, get: function() { return window$1; } });\n//# sourceMappingURL=runtime.esm.js.map\n"]}